//@author: a0096582r



	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter.cpp
	 */

Command*  Interpreter::interpretCommand(std::string commandStr, Messenger &response){

	bool isValidCommand=true;
	int commandType;

	string word;
	string issueCollector;
	Command* returnCommand=NULL;
	isValidCommand=checkCommand(commandStr,commandType);

	if(isValidCommand!=false){
		switch (commandType){
		case ADD_COMMAND:{
				Command_Add* Add_pointer=new Command_Add();
				Interpreter_Add interpretAdd;
				string taskName;
				extractQuotedMessage(commandStr, taskName);
				Add_pointer->setName(taskName);

				
				try{
					returnCommand=interpretAdd.interpretAdd(Add_pointer, commandStr, response,isValidCommand);
				}catch(string errorMessage){
	                 isValidCommand=false;					
					 issueCollector=errorMessage;
					 if(Add_pointer!=NULL){
						delete Add_pointer;
					}
				}
				break;
			}

		case MOD_COMMAND:{
				Command_Mod* Mod_pointer=new Command_Mod();
				Interpreter_Mod interpretMod;
				string taskName;
				extractQuotedMessage(commandStr, taskName);
				Mod_pointer->setName(taskName);

				try{
					returnCommand=interpretMod.interpretModify(Mod_pointer, commandStr, response,isValidCommand);
				}catch(string errorMessage){
					isValidCommand=false;					
					issueCollector=errorMessage;			     					
					if(Mod_pointer!=NULL){
						delete Mod_pointer;
					}				
				}
				break;
			}
		
		case MOD_EXACT_COMMAND:{
				Command_Mod* Mod_pointer=new Command_Mod();
				Interpreter_Mod interpretMod;
				string taskName;
				Mod_pointer->setFlagExact();	
				extractQuotedMessage(commandStr, taskName);
				Mod_pointer->setName(taskName);

				try{
					returnCommand=interpretMod.interpretModify(Mod_pointer, commandStr, response,isValidCommand);
				}catch(string errorMessage){
					isValidCommand=false;					
					issueCollector=errorMessage;
					if(Mod_pointer!=NULL){
						delete Mod_pointer;
					}			
				}
				break;
			}

		case MOD_INDEX_COMMAND:{
				Command_Mod* Mod_pointer=new Command_Mod();
				Interpreter_Mod interpretMod;	
				string getIndex=commandStr;
				stringstream extractIndex(getIndex);
				string content;
				extractIndex>>getIndex;
				getIndex.clear();
				extractIndex>>getIndex;
				int index;

				index=getIndexMessage(getIndex,isValidCommand);
				
				Mod_pointer->setIndex(index);

				try{
					returnCommand=interpretMod.interpretModify(Mod_pointer, commandStr, response,isValidCommand);
				}catch(string errorMessage){
					isValidCommand=false;					
					issueCollector=errorMessage;	
					if(Mod_pointer!=NULL){
						delete Mod_pointer;
					}				
				}							
				break;
			}


		case FIND_COMMAND:{
				Command_Find* Find_pointer=new Command_Find();
				Interpreter_Find interpretFind;
				try{
					returnCommand=interpretFind.interpretFind(Find_pointer,commandStr, response,isValidCommand);
				}catch(string errorMessage){
					isValidCommand=false;					
					issueCollector=errorMessage;					
					if(Find_pointer!=NULL){
						delete Find_pointer;
					}				
				}
				break;
			}

		case FIND_EXACT_COMMAND:{

				Command_Find* Find_pointer=new Command_Find();
				Interpreter_Find interpretFind;
				Find_pointer->setFlagExact();			
				try{
					returnCommand=interpretFind.interpretFind(Find_pointer,commandStr, response,isValidCommand);
				}catch(string errorMessage){
					isValidCommand=false;					
					issueCollector=errorMessage;			    				
					if(Find_pointer!=NULL){
						delete Find_pointer;
					}					
				}	
				break;
			}
		case DEL_COMMAND:{
				Command_Del* Del_pointer=new Command_Del();
				Interpreter_Delete interpretDel;								
				returnCommand=interpretDel.interpretDelete(Del_pointer,commandStr, response,isValidCommand);
				break;
			}
		case DEL_EXACT_COMMAND:{
				Command_Del* Del_pointer=new Command_Del();
                Interpreter_Delete interpretDel;						
				Del_pointer->setFlagExact();
				returnCommand=interpretDel.interpretDelete(Del_pointer,commandStr, response,isValidCommand);
				break;
			}
		case DEL_INDEX_COMMAND:{
				Command_Del* Del_pointer=new Command_Del();
				Interpreter_Delete interpretDel;
				stringstream extractIndex(commandStr);
				string content;
				int index;
				extractIndex>>commandStr;
				commandStr.clear();
				extractIndex>>commandStr;				
				index=getIndexMessage(commandStr,isValidCommand);				
				Del_pointer->setIndex(index);
				response.setCommandType(DEL);
				returnCommand=(Command*)Del_pointer;
				break;
			}
		case UNDO_COMMAND:{
				Command_Undo* Undo_pointer=new Command_Undo();
				Interpreter_Undo interpretUndo;
				returnCommand=interpretUndo.interpretUndo(Undo_pointer,commandStr, response,isValidCommand);
				break;
			}
		case REDO_COMMAND:{
				Command_Redo* Redo_pointer=new Command_Redo();
				Interpreter_Redo interpretRedo;
				returnCommand=interpretRedo.interpretRedo(Redo_pointer,commandStr, response,isValidCommand);
				break;
			}
		case INDEX_COMMAND:{
				int num;
				Command_Show* Show_pointer=new Command_Show();
				integerConvert(commandStr,num);
				Show_pointer->setIndex(num);
				response.setCommandType(SHOW);
				returnCommand=(Command*)Show_pointer;
				break;
			}
		default: isValidCommand=false;
			break;
		}

	}
	if(isValidCommand==false){
		response.setStatus(ERR);
		//if has not encountered any throw yet has error, command format is wrong
		if(!issueCollector.empty()){	
			response.setErrorMsg(issueCollector);	
		}		
		else{
			response.setErrorMsg(ERROR_COMMAND);
		}
	}

	else{
		response.setStatus(SUCCESS);
	}
	return returnCommand;
}

/**********************************************************************************
*Input: ActualIndex->index input by the user								      *
*		prevCommand->the previous Command object for the previous user input	  *
*																				  *
*Function: This function is called during "intermediate" case where the system    *
*		   returns multiple results with due to an ambiguous find/mod/del command.*
*		   These results have allocated indices and user can input an index to    *
*		   choose the corresponding task. This function parses the index and sets *
*		   it as an attribute of the previous Command object.                     *
*   	   					 													  *
*Ouput: prevCommand->previous Command object with index set						  *
*																				  *
**********************************************************************************/
void Interpreter::interpretCommand(unsigned ActualIndex, Command *prevCommand){
	
	TP::COMMAND_TYPE taskType;
	taskType=prevCommand->getCommandType();
	Command_Mod* Mod_pointer;
	Command_Del* Del_pointer;

	if(taskType==MOD){
		Mod_pointer=(Command_Mod*)prevCommand;
		Mod_pointer->setIndex(ActualIndex);
		prevCommand=Mod_pointer;
	}

	else if(taskType==DEL){

		Del_pointer=(Command_Del*)prevCommand;
		Del_pointer->setIndex(ActualIndex);
		prevCommand=Del_pointer;

	}
	return;
}

bool Interpreter::checkCommand(string command, int& commandType){

	bool isValidCommand=false;
	bool testlist[TOTAL_TEST_CASE]={false};
	int num=DUMMY_VALUE;

	regex test_add_command(COMMAND_ADD+GENERAL_ADD_CASE); 

	regex test_mod_command(COMMAND_MOD+GENERAL_MOD_CASE); 
	regex test_mod_exact_command(COMMAND_MOD_EXACT+GENERAL_MOD_CASE);
	regex test_mod_index_command(COMMAND_MOD_INDEX+GENERAL_MOD_CASE);

	regex test_find_command(COMMAND_FIND+GENERAL_FIND_CASE);
	regex test_find_exact_command(COMMAND_FIND_EXACT+GENERAL_FIND_CASE);

	regex test_del_command(COMMAND_DEL);
	regex test_del_exact_command(COMMAND_DEL_EXACT);
	regex test_del_index_command(COMMAND_DEL_INDEX);

	regex test_undo_command(COMMAND_UNDO);

	regex test_redo_command(COMMAND_REDO);
	regex test_index_command(COMMAND_INDEX);


	testlist[ADD_COMMAND]=regex_match(command,test_add_command);
	testlist[MOD_COMMAND]=regex_match(command,test_mod_command);
	testlist[MOD_EXACT_COMMAND]=regex_match(command,test_mod_exact_command);
	testlist[MOD_INDEX_COMMAND]=regex_match(command,test_mod_index_command);
	testlist[FIND_COMMAND]=regex_match(command,test_find_command);
	testlist[FIND_EXACT_COMMAND]=regex_match(command,test_find_exact_command);
	testlist[DEL_COMMAND]=regex_match(command,test_del_command);
	testlist[DEL_EXACT_COMMAND]=regex_match(command,test_del_exact_command);
	testlist[DEL_INDEX_COMMAND]=regex_match(command,test_del_index_command);
	testlist[UNDO_COMMAND]=regex_match(command,test_undo_command);
	testlist[REDO_COMMAND]=regex_match(command,test_redo_command);
	testlist[INDEX_COMMAND]=regex_match(command,test_index_command);

	for(int i=START_POSITION_VALUE;i<TOTAL_TEST_CASE && isValidCommand!=true;i++){
		if(testlist[i]==true){
			num=i;
			isValidCommand=true;
		}
	}

	commandType=num;
	return isValidCommand;
}

void Interpreter:: extractQuotedMessage(string field, string& quotedMessage){

	stringstream extract(field);
	getline(extract,quotedMessage,NOTATION_ACCENT_GRAVE);
	quotedMessage.clear();
	getline(extract,quotedMessage,NOTATION_ACCENT_GRAVE);
	return;
}

int Interpreter:: getIndexMessage(string command,bool& isSuccessful){

	int num;
	isSuccessful=integerConvert(command, num);
	return num;
}	

bool Interpreter::integerConvert(string& requiredString, int& number){
	
	bool isSuccessful=true;

	if(requiredString.empty()==true){
		isSuccessful=false;
	}
	else{
		for(unsigned i=START_POSITION_VALUE;i<requiredString.length();i++){
			if(isdigit(requiredString[i])==false){
				isSuccessful=false;
			}
		}
	}
	number=atoi(requiredString.c_str());

	return isSuccessful;
}

	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_Add.cpp
	 */

Command* Interpreter_Add::interpretAdd(Command_Add* commandType, string commandStr, Messenger &response, bool &flag){

	PRIORITY		contentPriority;
	string			contentString;
	list<string>	contentStringList;
	TASK_STATE		contentTaskState;
	TASK_TYPE		contentTaskType;
	time_t			contentTime;
	list<time_t>	contentTimeList;

	if(setDueDateMessage(commandStr,flag,contentTime)){		
		commandType->setDueDate(contentTime);		
	}		
	if(setFromDateMessage(commandStr,flag,contentTime)){
		commandType->setFromDate(contentTime);
	}
	if(setToDateMessage(commandStr,flag,contentTime)){
		commandType->setToDate(contentTime);
	}
	if(setParticipantsMessage(commandStr,flag,contentStringList,FIELD_PPL)){
		commandType->setParticipants(contentStringList);
	}
	if(setGeneralMessage(commandStr,flag,contentString,FIELD_NOTE)){
		commandType->setNote(contentString);
	}
	if(setGeneralMessage(commandStr,flag,contentString,FIELD_AT)){
		commandType->setLocation(contentString);
	}
	if(setRemindTimesMessage(commandStr,flag,contentTimeList,FIELD_RT)){
		commandType->setRemindTimes(contentTimeList);
	}
	if(setPriorityMessage(commandStr,flag,contentPriority)){
		commandType->setPriority(contentPriority);
	}
	if(setTagsMessage(commandStr,flag,contentStringList,FIELD_TAG)){
		commandType->setTags(contentStringList);
	}
	if(commandType->getFlagFrom()==true && commandType->getFlagTo()==true){
		if(commandType->getFromDate()>commandType->getToDate()){
			flag=false;
		}
	}

	if(flag==true){
		response.setStatus(SUCCESS);
		response.setCommandType(ADD);
	}
	else{
		delete commandType;
		commandType=NULL;
	}
	return (Command*)commandType;
}

	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_Add.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp
	 */

vector<string> Interpreter_base::extractNoParameterMessage(string command, string regexTemplate,int& count){
	string field;
	smatch match;
	string::const_iterator startPos = command.begin();
	string::const_iterator endPos = command.end();
	int startIndex=START_POSITION;
	vector<string>result;
	regex extractTemplate(regexTemplate);
	if (regex_search(startPos,endPos, match, extractTemplate)){
		field=match[START_POSITION];
	}
	while(!field.empty()){
		if(checkKeyWord(command,startIndex+match.position())==true){
			result.push_back(field);
			count++;
		}	
		startIndex=startIndex+match.position()+CHANGE_BY_ONE;
		startPos=startPos+match.position()+CHANGE_BY_ONE;
		field.clear();
		if(startPos!=endPos){
			if (regex_search(startPos,endPos, match, extractTemplate)){
				field=match[START_POSITION];
			}
		}
	}
	return result;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp
	 */

string Interpreter_base::toUpper(string str){
	transform(str.begin(), str.end(), str.begin(), ::toupper);
	return str;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp
	 */

void Interpreter_base::extractTimeWithZeroSlash( std::string &timeMessage, std::string &content, bool& isSuccessful, int& day, int& hour, int& min )
{
	int countSpace=EMPTY_ITEM;
	for(int i=START_POSITION;i<timeMessage.length();i++){
		if(timeMessage.at(i)==NOTATION_SPACE){
			countSpace++;
		}
	}
	//time format dd hh:mm
	if(countSpace==ONE_ITEM){
		stringstream extract(timeMessage);
		getline(extract,content,NOTATION_SPACE);
		if(!content.empty()){
			isSuccessful=integerConverter(content,day);
		}
		else{
			isSuccessful=false;
		}
		content.clear();
		getline(extract,content,NOTATION_COLON);
		if(!content.empty()){
			isSuccessful=integerConverter(content,hour);
		}
		content.clear();
		getline(extract,content);
		if(!content.empty()){
			isSuccessful=integerConverter(content,min);
		}
	}
	//time format hh/mm
	else if(countSpace==EMPTY_ITEM){
		stringstream extract(timeMessage);
		getline(extract,content,NOTATION_COLON);
		if(!content.empty()){
			isSuccessful=integerConverter(content,hour);
		}
		content.clear();
		getline(extract,content);
		if(!content.empty()){
			isSuccessful=integerConverter(content,min);
		}
	}
	else{
		isSuccessful=false;
	}
	return;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp
	 */

void Interpreter_base::extractTimeWithOneSlash( std::string timeMessage, std::string &content, bool& isSuccessful, int& day, int& month, int& hour, int& min )
{
	//time format dd/mm hh:mm
	stringstream extract(timeMessage);
	content.clear();
	getline(extract,content,NOTATION_SLASH);  
	isSuccessful=integerConverter(content,day);
	content.clear();
	getline(extract,content,NOTATION_SPACE); 
	isSuccessful=integerConverter(content,month);
	content.clear();
	getline(extract,content,NOTATION_COLON);
	if(!content.empty()){
		isSuccessful=integerConverter(content,hour);
	}
	content.clear();
	getline(extract,content);
	if(!content.empty()){
		isSuccessful=integerConverter(content,min);
	}
	return;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp
	 */

void Interpreter_base::extractTimeWithTwoSlash( std::string timeMessage, std::string &content, bool &isSuccessful, int& day, int& month, int &year, int& hour, int& min )
{
	//time format dd/mm/yy hh:mm
	stringstream extract(timeMessage);
	content.clear();
	getline(extract,content,NOTATION_SLASH);  
	isSuccessful=integerConverter(content,day);
	content.clear();
	getline(extract,content,NOTATION_SLASH); 
	isSuccessful=integerConverter(content,month);
	content.clear();
	getline(extract,content,NOTATION_SPACE); 
	isSuccessful=integerConverter(content,year);
	if(year<100)year=year+CURRENT_CENTURY;
	content.clear();
	getline(extract,content,NOTATION_COLON);
	if(!content.empty()){
		isSuccessful=integerConverter(content,hour);
	}
	content.clear();
	getline(extract,content);
	if(!content.empty()){
		isSuccessful=integerConverter(content,min);
	}
	return;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp
	 */

bool Interpreter_base::checkTimeValidity( int year, bool& isSuccessful, int month, int day, int hour, int min ){
	if(year>UPPER_LIMIT_YEAR || year<LOWER_LIMIT_YEAR)
		isSuccessful=false;
	else if(month>UPPER_LIMIT_MONTH)
		isSuccessful=false;
	else if(day>UPPER_LIMIT_DAY)
		isSuccessful=false;
	else if(hour>UPPER_LIMIT_HOUR)
		isSuccessful=false;
	else if(min>UPPER_LIMIT_MINUTE)
		isSuccessful=false;
	return isSuccessful;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp
	 */

bool Interpreter_base::isFromExistance( string command, smatch match, string &field, bool& isSuccessful ){
	regex checkFrom(FIELD_FROM);
	if (regex_search(command, match, checkFrom)){
		field=match[START_POSITION];
	}
	if(!field.empty()){
		isSuccessful=false;
	}	
	return isSuccessful;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp
	 */

bool Interpreter_base::isDueExistance( string &field, string command, smatch match, bool& isSuccessful ){
	regex checkDue(FIELD_DUE);
	field.clear();
	if (regex_search(command, match, checkDue)){
		field=match[START_POSITION];
	}
	if(!field.empty())isSuccessful=false;
	return isSuccessful;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp
	 */

bool Interpreter_base::isToExistance( string command, smatch match, string &field, bool& isSuccessful ){
	regex checkTo(FIELD_TO);
	if (regex_search(command, match, checkTo)){
		field=match[START_POSITION];
	}
	if(!field.empty()){
		isSuccessful=false;
	}	
	return isSuccessful;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp
	 */

int Interpreter_base::extractTagMessage( string &field, string &subString, smatch &match, list<string> &tagList, int count, regex extractTemplate ){
	while(!field.empty()){
		if(checkKeyWord(subString,match.position())==true){
			string tagContent;
			stringstream extract(field);
			getline(extract,tagContent,NOTATION_HASH);
			tagContent.clear();
			getline(extract,tagContent,NOTATION_SPACE);
			if(!tagContent.empty()){
				tagList.push_back(tagContent);
			}
			count++;
		}	
		subString=subString.substr(match.position()+CHANGE_BY_ONE);
		field.clear();
		if (regex_search(subString, match, extractTemplate)){
			field=match[START_POSITION];
		}
	}	
	return count;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp
	 */

void Interpreter_base::extractQuotedMessage(string field, string& QuotedMessage){

	stringstream extract(field);
	getline(extract,QuotedMessage,NOTATION_ACCENT_GRAVE);
	QuotedMessage.clear();
	getline(extract,QuotedMessage,NOTATION_ACCENT_GRAVE);
	return;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_base.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_Delete.cpp
	 */

Command* Interpreter_Delete:: interpretDelete(Command_Del*commandType,string commandStr, Messenger &response, bool &flag){

	stringstream extractContent(commandStr);
	string content;
	getline(extractContent,content,NOTATION_ACCENT_GRAVE);
	content.clear();
	getline(extractContent,content,NOTATION_ACCENT_GRAVE);
	commandType->setName(content);
	response.setCommandType(DEL);
	response.setStatus(SUCCESS);
	return (Command*)commandType;

}
	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_Delete.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_Find.cpp
	 */

Command* Interpreter_Find::interpretFind(Command_Find* commandType, string commandStr, Messenger &response, bool &flag){
	
	PRIORITY		contentPriority;
	string			contentString;
	list<string>	contentStringList;
	TASK_STATE		contentTaskState;
	TASK_TYPE		contentTaskType;
	time_t			contentTime;
	list<time_t>	contentTimeList;

	if(setFromDateMessage(commandStr,flag,contentTime)){
		commandType->setFromDate(contentTime);
	}
	if(setToDateMessage(commandStr,flag,contentTime)){
		commandType->setToDate(contentTime);
	}
	if(setParticipantsMessage(commandStr,flag,contentStringList,FIELD_PPL)){
		commandType->setParticipants(contentStringList);
	}
	if(setGeneralMessage(commandStr,flag,contentString,FIELD_NOTE)){
		commandType->setNote(contentString);
	}
	if(setGeneralMessage(commandStr,flag,contentString,FIELD_AT)){
		commandType->setLocation(contentString);
	}
	if(setRemindTimesMessage(commandStr,flag,contentTimeList,FIELD_RT)){
		commandType->setRemindTimes(contentTimeList);
	}
	if(setTagsMessage(commandStr,flag,contentStringList,FIELD_TAG)){
		commandType->setTags(contentStringList);
	}
	if(setGeneralMessage(commandStr,flag,contentString,FIELD_NAME)){
		commandType->setOptName(contentString);
	}
	if(setTaskStateMessage(commandStr,flag,contentTaskState)){
		commandType->setTaskState(contentTaskState);
	}
	if(setTaskTypeMessage(commandStr,flag,contentTaskType)){
		commandType->setTaskType(contentTaskType);
	}	
	if(setPriorityMessage(commandStr,flag,contentPriority)){
		commandType->setPriority(contentPriority);
	}
	
	if(commandType->getFlagFrom()==true && commandType->getFlagTo()==true){
		if(commandType->getFromDate()>commandType->getToDate()){
			flag=false;
		}
		//pull up and pull down if FromDate=DueDate
		if(commandType->getFromDate()==commandType->getToDate()){
			commandType->setFromDate(pullDownFromDate(commandType->getFromDate()));
			commandType->setToDate(pushUpToDate(commandType->getToDate()));
		}
	}

	if(flag==true){
		response.setStatus(SUCCESS);
		response.setCommandType(FIND);
	}
	else{ 
		delete commandType;
		commandType=NULL;
	}
	return (Command*)commandType;
}

time_t Interpreter_Find::pullDownFromDate(time_t givenTime){
	struct tm pulledDownTime;
	localtime_s(&pulledDownTime,&givenTime);
	pulledDownTime.tm_hour=PULLED_DOWN_HOUR;
	pulledDownTime.tm_min=PULLED_DOWN_MIN;

	return mktime(&pulledDownTime);
}
time_t Interpreter_Find::pushUpToDate(time_t givenTime){
	struct tm pushedUpTime;
	localtime_s(&pushedUpTime,&givenTime);
	pushedUpTime.tm_hour=PUSHED_UP_HOUR;
	pushedUpTime.tm_min=PUSHED_UP_MIN;

	return mktime(&pushedUpTime);
}



	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_Find.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Interpreter_Mod.cpp
	 */

Command* Interpreter_Mod ::interpretModify(Command_Mod* commandType, string commandStr, Messenger &response, bool &flag){

	PRIORITY		contentPriority;
	string			contentString;
	list<string>	contentStringList;
	TASK_STATE		contentTaskState;
	TASK_TYPE		contentTaskType;
	time_t			contentTime;
	list<time_t>	contentTimeList;

	if(setDueDateMessage(commandStr,flag,contentTime)){		
		commandType->setDueDate(contentTime);		
	}		
	if(setFromDateMessage(commandStr,flag,contentTime)){
		commandType->setFromDate(contentTime);
	}
	if(setToDateMessage(commandStr,flag,contentTime)){
		commandType->setToDate(contentTime);
	}
	if(setParticipantsMessage(commandStr,flag,contentStringList,FIELD_PPL)){
		commandType->setParticipants(contentStringList);
	}
	if(setGeneralMessage(commandStr,flag,contentString,FIELD_NOTE)){
		commandType->setNote(contentString);
	}
	if(setGeneralMessage(commandStr,flag,contentString,FIELD_AT)){
		commandType->setLocation(contentString);
	}
	if(setRemindTimesMessage(commandStr,flag,contentTimeList,FIELD_RT)){
		commandType->setRemindTimes(contentTimeList);
	}
	if(setPriorityMessage(commandStr,flag,contentPriority)){
		commandType->setPriority(contentPriority);
	}
	if(setTagsMessage(commandStr,flag,contentStringList,FIELD_TAG)){
		commandType->setTags(contentStringList);
	}
	if(setGeneralMessage(commandStr,flag,contentString,FIELD_NAME)){
		commandType->setOptName(contentString);
	}
	if(setTaskStateMessage(commandStr,flag,contentTaskState)){
		commandType->setTaskState(contentTaskState);
	}
	if(setNoParameterMessage(commandStr,flag,FIELD_DUE_REMOVE)){
		commandType->setFlagRemoveDue();
	}
	if(setNoParameterMessage(commandStr,flag,FIELD_FROM_REMOVE)){
		commandType->setFlagRemoveFrom();
	}
	if(setNoParameterMessage(commandStr,flag,FIELD_TO_REMOVE)){
		commandType->setFlagRemoveTo();
	}
	if(setNoParameterMessage(commandStr,flag,FIELD_RT_REMOVE_ALL)){
		commandType->setFlagRemoveAllRemindTimes();
	}
	if(setNoParameterMessage(commandStr,flag,FIELD_PPL_REMOVE_ALL)){
		commandType->setFlagRemoveAllParticipants();
	}
	if(setNoParameterMessage(commandStr,flag,FIELD_TAG_REMOVE_ALL)){
		commandType->setFlagRemoveAllTags();
	}
	if(setRemindTimesMessage(commandStr,flag, contentTimeList,FIELD_RT_REMOVE)){
		commandType->setRemoveRemindTimes(contentTimeList);
	}
	if(setParticipantsMessage(commandStr,flag, contentStringList,FIELD_PPL_REMOVE)){
		commandType->setRemoveParticipants(contentStringList);
	}
	else if(setTagsMessage(commandStr,flag, contentStringList,FIELD_TAG_REMOVE)){
		commandType->setRemoveTags(contentStringList);
	}
	if(setRemindTimesMessage(commandStr,flag, contentTimeList,FIELD_RT_ADD)){
		commandType->setAddRemindTimes(contentTimeList);
	}
	if(setParticipantsMessage(commandStr,flag, contentStringList,FIELD_PPL_ADD)){
		commandType->setAddParticipants(contentStringList);
	}
	if(setTagsMessage(commandStr,flag, contentStringList,FIELD_TAG_ADD)){
		commandType->setAddTags(contentStringList);
	}

	if(commandType->getFlagFrom()==true && commandType->getFlagTo()==true){
		if(commandType->getFromDate()>commandType->getToDate()){
			flag=false;
		}
	}

	if(flag==true){
		response.setStatus(SUCCESS);
		response.setCommandType(MOD);
	}
	else{
		delete commandType;
		commandType=NULL;
	}
	return (Command*)commandType;
}

	// End of segment: C:\Users\a0102016\Desktop\asd\Interpreter_Mod.cpp





