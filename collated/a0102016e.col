//@author: a0102016e



	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Command.cpp
	 */

using namespace std;
using namespace TP;

const bool				Command::DEFAULT_FLAG					= UNCHANGED;
const COMMAND_TYPE		Command::DEFAULT_COMMAND_TYPE			= UNDEFINED;
const PRIORITY			Command::DEFAULT_PRIORITY				= MEDIUM;
const TASK_STATE		Command::DEFAULT_TASK_STATE				= UNDONE;//undone
const TASK_TYPE			Command::DEFAULT_TASK_TYPE				= FLOATING;
const string			Command::DEFAULT_STRING					= "";
const list<string>		Command::DEFAULT_LIST_OF_STRING			= list<string>();
const time_t			Command::DEFAULT_TIME					= -1;
const list<time_t>		Command::DEFAULT_REMIND_TIME			= list<time_t>();
const int				Command::DEFAULT_INDEX					= -1;
const unsigned long long Command::DEFAULT_CREATED_TIME			= 0;

void Command::init()
{
	//flags init
	FLAG_index			                            = DEFAULT_FLAG;
	FLAG_exact			                            = DEFAULT_FLAG;
	FLAG_name			                            = DEFAULT_FLAG;
	FLAG_optName		                            = DEFAULT_FLAG;
	FLAG_due			                            = DEFAULT_FLAG;
	FLAG_removeDue									= DEFAULT_FLAG;
	FLAG_from			                            = DEFAULT_FLAG;
	FLAG_removeFrom									= DEFAULT_FLAG;
	FLAG_to				                            = DEFAULT_FLAG;
	FLAG_removeTo									= DEFAULT_FLAG;
	FLAG_location		                            = DEFAULT_FLAG;
	FLAG_participants	                            = DEFAULT_FLAG;
	FLAG_removeParticipants							= DEFAULT_FLAG;
	FLAG_addParticipants							= DEFAULT_FLAG;
	FLAG_removeAllParticipants						= DEFAULT_FLAG;
	FLAG_note			                            = DEFAULT_FLAG;
	FLAG_priority		                            = DEFAULT_FLAG;
	FLAG_tags			                            = DEFAULT_FLAG;
	FLAG_removeTags									= DEFAULT_FLAG;
	FLAG_addTags									= DEFAULT_FLAG;
	FLAG_removeAllTags								= DEFAULT_FLAG;
	FLAG_remindTime		                            = DEFAULT_FLAG;
	FLAG_removeRemindTime							= DEFAULT_FLAG;
	FLAG_addRemindTime								= DEFAULT_FLAG;
	FLAG_removeAllRemindTimes						= DEFAULT_FLAG;
	FLAG_taskState		                            = DEFAULT_FLAG;
	FLAG_createdTime	                            = DEFAULT_FLAG;
	FLAG_taskType		                            = DEFAULT_FLAG;

	//fields init
	_type				                            = DEFAULT_COMMAND_TYPE;
	_index				                            = DEFAULT_INDEX;
	_name				                            = DEFAULT_STRING;
	_optName			                            = DEFAULT_STRING;
	_dueDate			                            = DEFAULT_TIME;
	_fromDate			                            = DEFAULT_TIME;
	_toDate				                            = DEFAULT_TIME;
	_location			                            = DEFAULT_STRING;
	_participants		                            = DEFAULT_LIST_OF_STRING;
	_removeParticipants								= DEFAULT_LIST_OF_STRING;
	_addParticipants								= DEFAULT_LIST_OF_STRING;
	_note				                            = DEFAULT_STRING;
	_priority			                            = DEFAULT_PRIORITY;
	_tags				                            = DEFAULT_LIST_OF_STRING;
	_removeTags										= DEFAULT_LIST_OF_STRING;
	_addTags										= DEFAULT_LIST_OF_STRING;
	_remindTime			                            = DEFAULT_REMIND_TIME;
	_removeRemindTime								= DEFAULT_REMIND_TIME;
	_addRemindTime									= DEFAULT_REMIND_TIME;
	_taskState			                            = DEFAULT_TASK_STATE;
	_createdTime		                            = DEFAULT_CREATED_TIME;
	_taskType			                            = DEFAULT_TASK_TYPE;
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Command.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\CommandBar.cpp
	 */

const int CommandBar::TOO_LONG		= 777;
const int CommandBar::MAX_LENGTH	= 777;
const QStringList CommandBar::COMMAND_LIST = QStringList() \
	<< "add ``" << "mod" << "del" << "find" << "undo" <<     \
	"redo";
const QStringList CommandBar::KEYWORD_LIST = QStringList() \
	<< "name ``" << "by ``" << "due ``" << "from ``" << "to ``" << "location ``" << "place ``" << "at ``" << \
	"with ``" << "ppl ``" << "note ``" << "priority ``" << "impt ``" << "rt ``" << "remind ``" << "done" << \
	"undone" <<  "exact ``";
const QStringList CommandBar::KEYWORD_LIST_REMOVE = QStringList() \
	<< "by" << "due" << "from" << "to" << "with ``" << "ppl ``" << "pplall" << "rt ``" << "remind ``" \
	<< "rtall";
const QStringList CommandBar::KEYWORD_LIST_ADD = QStringList() \
	<< "with ``" << "ppl ``" << "rt ``" << "remind ``";
const QStringList CommandBar::KEYWORD_LIST_FIND = QStringList() \
	<< "name ``" << "from ``" << "to ``" << "location ``" << "place ``" << "at ``" << "with ``" << "ppl ``" \
	<< "note ``" << "priority ``" << "impt ``" << "rt ``" << "remind ``" << "overdue" << "done" << "undone" <<  \
	"deadline" << "timed" << "floating" << "exact name ``";
const char*	  CommandBar::NEW_LINE                     = "\n";
const QString CommandBar::SPACE                        = " ";
const QString CommandBar::INCLUDE_QUOTE_LEFT_PAIR      = "(\\w+ ``)|( ``)|(``)";
const QString CommandBar::SINGLE_QUOTATION_MARK        = "'";
const QString CommandBar::QUOTE_LEFT                   = "`";
const QString CommandBar::QUOTE_LEFT_PAIR              = "`(.*)`";
const QString CommandBar::EMPTY                        = "";
const QString CommandBar::HOTKEY_TEMPLATE_ADD          = "add `__NAME__` due `__DATE__` impt `__PRIORITY__` "\
	"at `__WHERE__` ppl `__PARTICIPANTS__` #__TAGS__ rt `__REMINDTIME__` note `__NOTE__`";
const QString CommandBar::HOTKEY_TEMPLATE_ADD_TIMED    = "add `__NAME__` from `__DATE__` to `__DATE__` impt `"\
	"__PRIORITY__` at `__WHERE__` ppl `__PARTICIPANTS__` #__TAGS__ rt `__REMINDTIME__` note `__NOTE__`";
const QString CommandBar::HOTKEY_TEMPLATE_MOD_DONE     = "mod __INDEX__ done";
const QString CommandBar::HOTKEY_TEMPLATE_MOD_BY_NAME  = "mod `__NAME__` name `__MODIFIEDNAME__` from `__DATE"\
	"__` to `__DATE__` impt `__PRIORITY__` at `__WHERE__` ppl `__PARTICIPANTS__` #__TAGS__ rt `__REMINDTIME__"\
	"` note `__NOTE__` __DONE__";
const QString CommandBar::HOTKEY_TEMPLATE_MOD_BY_INDEX = "mod __INDEX__ name `__MODIFIEDNAME__` from `__DATE_"\
	"_` to `__DATE__` impt `__PRIORITY__` at `__WHERE__` ppl `__PARTICIPANTS__` #__TAGS__ rt `__REMINDTIME__`"\
	" note `__NOTE__` __DONE__";
const QString CommandBar::HOTKEY_TEMPLATE_DEL_BY_NAME  = "del `__NAME__`";
const QString CommandBar::HOTKEY_TEMPLATE_DEL_BY_INDEX = "del __INDEX__";
const QString CommandBar::HOTKEY_TEMPLATE_FIND         = "find name `__NAME__` from `__DATE__` to `__DATE__` "\
	"impt `__PRIORITY__` at `__WHERE__` ppl `__PARTICIPANTS__` note `__NOTE__`";
const QString CommandBar::HOTKEY_TEMPLATE_UNDO         = "undo";
const QString CommandBar::HOTKEY_TEMPLATE_REDO         = "redo";
const QString CommandBar::HOTKEY_TEMPLATE_BLANK        = "__[A-Z]+__";

CommandBar::CommandBar(QWidget *parent)
:QTextEdit(parent), inputHistory_undo(), inputHistory_redo(){
	initRegExp();
	initWidgets();
	initConnections();
}

void CommandBar::initRegExp(){
	hotkeyTemplate.setPattern(HOTKEY_TEMPLATE_BLANK);
	hotkeyTemplate.setPatternSyntax(QRegExp::RegExp2);
	REGEXP_quoteLeftPairs.setPattern(QUOTE_LEFT_PAIR);
	REGEXP_quoteLeftPairs.setPatternSyntax(QRegExp::RegExp2);
	REGEXP_quoteLeftPairs.setMinimal(true);
}

void CommandBar::initWidgets(){
	initState();
	initModel();
	initCompleter();
}

//Highlighter will be deleted by its parent (class CommandBar)
//No memory leak here, it's just a Qt's feature.
//DO NOT DELETE IT! otherwise you delete it twice and abort.
void CommandBar::initState(){
	autoCompleteToggle(true);
	hotkeyTemplateMode = false;
	autoCompleteMode = false;
	(void) new Highlighter(document());
}

//Model is used by Completer to produce words to complete what users type
void CommandBar::initModel(){
	model = new QStringListModel(this);
	produceCommandModel();
}

void CommandBar::initCompleter(){
	completer = new QCompleter(this);
	completer->setWidget(this);
	completer->setCompletionMode(QCompleter::InlineCompletion);
	completer->setModel(model);
	completer->setModelSorting(QCompleter::UnsortedModel);
	completer->setCaseSensitivity(Qt::CaseInsensitive);
	completer->setWrapAround(true);
}

//all QShortcut will be deleted by their parent (class CommandBar) automatically
//it's a Qt feature. 
//DO NOT DELETE THEM! otherwise you delete them twice and abort.
void CommandBar::initConnections(){
	const char* NEW_DEADLINE_TASK    = "Ctrl+N";
	const char* NEW_TIMED_TASK       = "Ctrl+Shift+N";
	const char* MOD_TASK_DONE        = "Ctrl+M";
	const char* MOD_TASK_BY_NAME     = "Ctrl+Alt+Shift+M";
	const char* MOD_TASK_BY_INDEX    = "Ctrl+Shift+M";
	const char* DEL_TASK_BY_NAME     = "Ctrl+Shift+D";
	const char* DEL_TASK_BY_INDEX    = "Ctrl+D";
	const char* FIND_TASK            = "Ctrl+F";
	const char* UNDO                 = "Ctrl+U";
	const char* REDO                 = "Ctrl+R";
	const char* JUMP_BACK_PREV_BLANK = "Shift+Tab";

	connect(this, SIGNAL(textChanged()), this, SLOT(performCompletion()));
	newDeadlineTask = new QShortcut(QKeySequence(NEW_DEADLINE_TASK), this, SLOT(createTemplateAdd()));
	newTimedTask    = new QShortcut(QKeySequence(NEW_TIMED_TASK), this, SLOT(createTemplateAddTimed()));
	modifyDone      = new QShortcut(QKeySequence(MOD_TASK_DONE), this, SLOT(createTemplateModDone()));
	modifyByName    = new QShortcut(QKeySequence(MOD_TASK_BY_NAME), this, SLOT(createTemplateModByName()));
	modifyByIndex   = new QShortcut(QKeySequence(MOD_TASK_BY_INDEX), this, SLOT(createTemplateModByIndex()));
	delByName       = new QShortcut(QKeySequence(DEL_TASK_BY_NAME), this, SLOT(createTemplateDelByName()));
	delByIndex      = new QShortcut(QKeySequence(DEL_TASK_BY_INDEX), this, SLOT(createTemplateDelByIndex()));
	find            = new QShortcut(QKeySequence(FIND_TASK), this, SLOT(createTemplateFind()));
	undo            = new QShortcut(QKeySequence(UNDO), this, SLOT(createTemplateUndo()));
	redo            = new QShortcut(QKeySequence(REDO), this, SLOT(createTemplateRedo()));
	(void)            new QShortcut(QKeySequence(JUMP_BACK_PREV_BLANK), this, SLOT(hkTemplateGoBackwards()));
}

QString CommandBar::getCurrentLine(){
	QRegExp regex(HOTKEY_TEMPLATE_BLANK);
	QString result = toPlainText();
	result.replace(regex, EMPTY);
	return result;
}

//push current line into input history
//then user can use up/down arrow to read thru them
void CommandBar::pushCurrentLine(){
	QString currentInput = toPlainText();
	if(currentInput != EMPTY){
		while(!inputHistory_redo.isEmpty()){
			QString input = inputHistory_redo.pop();
			inputHistory_undo.push(input);
		}
		inputHistory_undo.push(currentInput);
		clear();
	}
}

//it's used by MACRO:
//#define TEXT_EDIT_BEGIN	autoCompleteToggle(false);
//#define TEXT_EDIT_END		autoCompleteToggle(true);
//#define TURN_OFF_AC		autoCompleteToggle(false);
//#define TURN_ON_AC		autoCompleteToggle(true);
//make the coding more readable :p
void CommandBar::autoCompleteToggle(bool flag){
	autoCompleteFlag = flag;
}

//when textChanged, this function will be called by textChanged signal
void CommandBar::performCompletion(){
	produceModel();
	if(getCurrentLine().length() > TOO_LONG){
		handleTextTooLong();
	}
	else if(autoCompleteFlag && isRHSEmpty()){
			QString completionPrefix = getWordUnderCursor();
			if (!completionPrefix.isEmpty() &&
				isLastCharLetter(completionPrefix)){
					performCompletion(completionPrefix);
			}
	}
}

bool CommandBar::isRHSEmpty(){
	bool isRHSaSpace = hasKeywordNearby(SPACE, QTextCursor::Right);
	bool isAtTheEndOfLine = textCursor().position() == getCurrentLine().length();
	return isRHSaSpace || isAtTheEndOfLine;
}

void CommandBar::produceModel(){
	//produce empty model if within `` or after #..
	if(isWithinPairOfQuoteLeft() || hasSharpAtStartOfWord()){
		model->setStringList(QStringList());
	}//produce keyword model for -xxx keyword
	else if(!isWithinPairOfQuoteLeft() && hasMinusAtStartOfWord()){
		model->setStringList(KEYWORD_LIST_REMOVE);
	}//produce keyword model for +xxx keyword
	else if(!isWithinPairOfQuoteLeft() && hasPlusAtStartOfWord()){
		model->setStringList(KEYWORD_LIST_ADD);
	}
	else if(containsCommand()){
		//special keyword model for command Find
		if(isCommandFind())
			produceKeywordModel_forFind();
		else//normal keyword model for all kinds of command
			produceKeywordModel();
	}
	else{//produce command model
		produceCommandModel();
	}
}

void CommandBar::produceCommandModel(){
	model->setStringList(COMMAND_LIST);
}

void CommandBar::produceKeywordModel(){
	model->setStringList(KEYWORD_LIST);
}

void CommandBar::produceKeywordModel_forFind(){
	model->setStringList(KEYWORD_LIST_FIND);
}

bool CommandBar::isLastCharLetter(QString str){
	const int END_INDEX = str.length() - 1;
	bool result = str.at(END_INDEX).isLetter();
	return result;
}

//just remove the too-long text, and move the cursor to the end of line
void CommandBar::handleTextTooLong(){
	QString currContent = getCurrentLine();
	QTextCursor cursor = textCursor();
	cursor.movePosition(QTextCursor::EndOfLine);
	int pos = cursor.position();
	currContent.remove(MAX_LENGTH, pos);
	setText(currContent);
	setTextCursor(cursor);
}

void CommandBar::performCompletion(const QString &completionPrefix){
	const int NOT_FOUND = 0;
	if (completionPrefix != completer->completionPrefix()){
		completer->setCompletionPrefix(completionPrefix);
	}
	if (completer->completionCount() > NOT_FOUND){
		insertCompletion(completer->currentCompletion());
	}
}

void CommandBar::insertCompletion(const QString &completion){
	const int NOT_FOUND = 0;
	QTextCursor cursor = textCursor();
	int numberOfCharsToComplete = completion.length() - completer->completionPrefix().length();
	if(numberOfCharsToComplete > NOT_FOUND){
		//start auto-complete
		int insertionPosition = cursor.position();
		//select the input text, override later
		cursor.movePosition(QTextCursor::StartOfWord, QTextCursor::KeepAnchor);
		//in case of auto-complete infinite loop
		TEXT_EDIT_BEGIN
		cursor.insertHtml( completion );
		TEXT_EDIT_END
		//back to previous cursor position
		cursor.setPosition(insertionPosition);
		//move cursor to end of completion
		cursor.movePosition(QTextCursor::Right, QTextCursor::KeepAnchor, numberOfCharsToComplete);
		setTextCursor(cursor);
		autoCompleteMode = true;
	}
}

//make copy or paste data from Web plain
void CommandBar::insertFromMimeData(const QMimeData *source){
	if(source->hasText()){
		makeTextPlain(source);
	}
}

void CommandBar::makeTextPlain( const QMimeData * source ){
	QString strToInsert = source->text();
	strToInsert.replace(QRegExp(NEW_LINE), EMPTY);
	insertPlainText(strToInsert);
}

bool CommandBar::containsQuoteLeftPair(QString str){
	const int NOT_FOUND = -1;
	QRegExp regex(INCLUDE_QUOTE_LEFT_PAIR);
	int index = regex.indexIn(str);
	return index != NOT_FOUND;
}

bool CommandBar::isWithinPairOfQuoteLeft(){
	bool result = false;
	QVector<QPair<int, int> > quoteLeftPositions = getQuoteLeftPositions();
	for(int i = 0; i < quoteLeftPositions.size(); i++){
		int leftQuoteLeftPos = quoteLeftPositions[i].first;
		int rightQuoteLeftPos = quoteLeftPositions[i].second;
		int currentPos = textCursor().position();
		if(leftQuoteLeftPos < currentPos && currentPos <= rightQuoteLeftPos){
			result = true;
			break;
		}
	}
	return result;
}

//produce pairs of Quote Lefts:
//Assumption made: if the number of QL is odd, the last QL is neglected
QVector<QPair<int, int> > CommandBar::getQuoteLeftPositions(){
	const int NOT_FOUND = -1;
	QString	currentLine = getCurrentLine();
	int index = REGEXP_quoteLeftPairs.indexIn(currentLine);
	QVector<QPair<int, int> > result;

	while (index > NOT_FOUND) {
		int length = REGEXP_quoteLeftPairs.matchedLength();
		int first_pos = index;
		int second_pos = index + length - 1;
		int next = index + length;
		result.push_back(QPair<int, int>(first_pos, second_pos));
		index = REGEXP_quoteLeftPairs.indexIn(currentLine, next);
	}

	return result;
}

//handling of odd number of QL will use this function
bool CommandBar::isEvenQuoteLefts(){
	const int NOT_FOUND = -1;
	const int EVEN = 2;
	int count = 0;
	int pos = 0;
	QRegExp REGEXP_ql(QUOTE_LEFT);
	QString currentLine = getCurrentLine();
	
	while ((pos = REGEXP_ql.indexIn(currentLine, pos)) != NOT_FOUND) {
		++count;
		pos += REGEXP_ql.matchedLength();
	}
	QVector<QPair<int, int> > quoteLeftPositions = getQuoteLeftPositions();
	return count == quoteLeftPositions.size() * EVEN;
}

bool CommandBar::isHotkeyTemplateMode(){
	bool result = true;
	QTextCursor cursor = textCursor();

	cursor.movePosition(QTextCursor::Start);
	QTextCursor result_cursor = document()->find(hotkeyTemplate, cursor);
	if(result_cursor.isNull()){
		result = false;
	}
	return result;
}

QString CommandBar::getWordUnderCursor(){
	QTextCursor cursor = textCursor();
	cursor.select(QTextCursor::WordUnderCursor);
	QString completionPrefix = cursor.selectedText();

	return completionPrefix;
}

//check whether has a certain keyword next to the cursor
bool CommandBar::hasKeywordNearby(QString keyword, QTextCursor::MoveOperation direction){
	QTextCursor cursor = textCursor();
	cursor.movePosition(direction, QTextCursor::KeepAnchor);
	QString str = cursor.selectedText();

	return str == keyword;
}

bool CommandBar::hasQuoteLeft_RHS(){
	return hasKeywordNearby(QUOTE_LEFT, QTextCursor::Right);
}

bool CommandBar::hasQuoteLeft_LHS(){
	return hasKeywordNearby(QUOTE_LEFT, QTextCursor::Left);
}

bool CommandBar::hasKeywordAtStartOfWord(const char* keyword){
	QTextCursor cursor = textCursor();
	cursor.movePosition(QTextCursor::StartOfWord);
	cursor.movePosition(QTextCursor::Left, QTextCursor::KeepAnchor);
	QString str = cursor.selectedText();

	return str == keyword;
}

bool CommandBar::hasSharpAtStartOfWord(){
	const char* SHARP = "#";
	return hasKeywordAtStartOfWord(SHARP);
}

bool CommandBar::hasPlusAtStartOfWord(){
	const char* PLUS = "+";
	return hasKeywordAtStartOfWord(PLUS);
}

bool CommandBar::hasMinusAtStartOfWord(){
	const char* MINUS = "-";
	return hasKeywordAtStartOfWord(MINUS);
}

//clear a character next to the cursor
void CommandBar::clearCharNearby(QTextCursor::MoveOperation direction){
	QTextCursor cursor = textCursor();
	cursor.movePosition(direction, QTextCursor::KeepAnchor);
	cursor.removeSelectedText();
	setTextCursor(cursor);
}

void CommandBar::clearCharRHS(){
	clearCharNearby(QTextCursor::Right);
}

void CommandBar::clearCharLHS(){
	clearCharNearby(QTextCursor::Left);
}

bool CommandBar::isCommandFind(){
	const char* CMD_FIND = "find ";
	QString currentLine = getCurrentLine();
	return currentLine.startsWith(CMD_FIND, Qt::CaseInsensitive);
}

bool CommandBar::containsCommand(){
	const QString CMD_PATTERN = "^(add|mod|del|find|undo|redo) ";
	const int UNFOUND = -1;
	QString currentLine = textCursor().block().text();
	QRegExp regex(CMD_PATTERN);
	int index = regex.indexIn(currentLine);

	return index != UNFOUND;
}

//******************************
//ENTRANCE of KEY PRESS HANDLING
//******************************
void CommandBar::keyPressEvent(QKeyEvent*event){
	bool isHandled = handleKeyPress(event);
	if(!isHandled){
		QTextEdit::keyPressEvent(event);
	}
}

bool CommandBar::handleKeyPress(QKeyEvent*event){
	bool isHandled = false;
	switch(event->key()){
	case Qt::Key_QuoteLeft:
		if(event->modifiers() != Qt::ShiftModifier)
			handleKeyQuoteLeft(&isHandled);
		break;
	case Qt::Key_Escape:
			handleKeyEscape(&isHandled);
		break;
	case Qt::Key_Tab:
			handleKeyTab(&isHandled);
		break;
	case Qt::Key_Space:
			handleKeySpace(&isHandled);
		break;
	case Qt::Key_Delete:
			handleKeyDelete(&isHandled);
		break;
	case Qt::Key_Backspace:
			handleKeyBackspace(&isHandled);
		break;
	case Qt::Key_Left:
	case Qt::Key_Right:
		if(event->modifiers() == Qt::ShiftModifier)
			handleKeyLeftOrRight();
		break;
	case Qt::Key_Up:
			handleKeyUp();
		break;
	case Qt::Key_Down:
			handleKeyDown();
		break;
	default:
			handleKeyDefault();
		break;
	}
	return isHandled;
}

void CommandBar::handleKeyQuoteLeft(bool *isHandled){
	TURN_OFF_AC
	QTextCursor cursor = textCursor();
	//in auto-completion, press QL will move the cursor between ``, if 
	//the model has `` pair
	if(autoCompleteMode && containsQuoteLeftPair(cursor.selectedText())){
		cursor.clearSelection();
		cursor.movePosition(QTextCursor::Left);
		autoCompleteMode = false;
	}//if the model does not have `` pair, insert `` at the back of it
	else if(autoCompleteMode && cursor.selectedText() != EMPTY){
		cursor.clearSelection();
		cursor.insertText(SPACE + QUOTE_LEFT + QUOTE_LEFT);
		cursor.movePosition(QTextCursor::Left, QTextCursor::MoveAnchor);
		autoCompleteMode = false;
	}//normal processing
	else if(!autoCompleteMode && cursor.selectedText() != EMPTY){
		cursor.removeSelectedText();
		cursor.insertText(QUOTE_LEFT + QUOTE_LEFT);
		cursor.movePosition(QTextCursor::Left, QTextCursor::MoveAnchor);
	}//if within ``, and has a ` next to the cursor (RHS), then go across it
	else if(isWithinPairOfQuoteLeft() && hasQuoteLeft_RHS()){
		cursor.movePosition(QTextCursor::Right, QTextCursor::MoveAnchor);
		cursor.insertText(SPACE);
	}//if not within ``, and has even number of QL, insert ``
	else if(!isWithinPairOfQuoteLeft() && isEvenQuoteLefts()){
		cursor.insertText(QUOTE_LEFT + QUOTE_LEFT);
		cursor.movePosition(QTextCursor::Left, QTextCursor::MoveAnchor);
	}
	else{//other case, just insert `
		cursor.insertText(QUOTE_LEFT);
	}
	setTextCursor(cursor);
	*isHandled = true;
}

void CommandBar::handleKeyEscape(bool *isHandled){
	QTextCursor cursor = textCursor();
	TEXT_EDIT_BEGIN
	cursor.removeSelectedText();
	TEXT_EDIT_END
	setTextCursor(cursor);
	*isHandled = true;
}

//used by shift+tab
void CommandBar::hkTemplateGoBackwards(){
	QTextCursor cursor = textCursor();
	if(isHotkeyTemplateMode()){
		handleHotKeyGoBackwards();
	}
}

void CommandBar::handleHotKeyGoBackwards(){
	lastTimeCursor = document()->find(hotkeyTemplate, textCursor(), QTextDocument::FindBackward);
	if(lastTimeCursor.isNull()){
		moveCursor(QTextCursor::End);
		lastTimeCursor = document()->find(hotkeyTemplate, textCursor(), QTextDocument::FindBackward);
		if(lastTimeCursor.isNull()){
			hotkeyTemplateMode = false;
		}
	}
	if(!(lastTimeCursor.isNull())){
		int length = lastTimeCursor.selectedText().length();
		lastTimeCursor.clearSelection();
		lastTimeCursor.movePosition(QTextCursor::Left, QTextCursor::KeepAnchor, length);
		setTextCursor(lastTimeCursor);
	}
}

void CommandBar::handleHotKeyGoForwards(){
	lastTimeCursor = document()->find(hotkeyTemplate, textCursor());
	if(lastTimeCursor.isNull()){
		moveCursor(QTextCursor::Start);
		lastTimeCursor = document()->find(hotkeyTemplate, textCursor());
		if(lastTimeCursor.isNull()){
			hotkeyTemplateMode = false;
		}
	}
	if(!(lastTimeCursor.isNull())){
		setTextCursor(lastTimeCursor);
		int length = lastTimeCursor.selectedText().length();
		lastTimeCursor.clearSelection();
		lastTimeCursor.movePosition(QTextCursor::Left, QTextCursor::KeepAnchor, length);
		setTextCursor(lastTimeCursor);
	}
}

void CommandBar::handleKeyTab(bool *isHandled){
	TURN_OFF_AC
	QTextCursor cursor = textCursor();
	if(isHotkeyTemplateMode()){
		handleHotKeyGoForwards();
		*isHandled = true;
	}
	else{
		//auto complete the keyword model in auto-complete mode
		if(autoCompleteMode && containsQuoteLeftPair(cursor.selectedText())){
			cursor.clearSelection();
			cursor.movePosition(QTextCursor::Left);
			autoCompleteMode = false;
		}//normal processing
		else if(!autoCompleteMode && cursor.selectedText() != EMPTY){
			cursor.removeSelectedText();
			cursor.insertText(SPACE);
		}//move across the quote left `
		else if(hasQuoteLeft_RHS()){
			cursor.movePosition(QTextCursor::Right);
			cursor.insertText(SPACE);
		}//just insert a space
		else{
			cursor.clearSelection();
			cursor.insertText(SPACE);
		}
		*isHandled = true;
		setTextCursor(cursor);
	}
}

void CommandBar::handleKeySpace(bool *isHandled){
	TURN_OFF_AC
	QTextCursor cursor = textCursor();
	if(cursor.hasSelection() && autoCompleteMode){
		//auto complete the keyword model in auto-complete mode, if it has ``
		if(containsQuoteLeftPair(cursor.selectedText())){
			cursor.clearSelection();
			cursor.movePosition(QTextCursor::Left);
		}//otherwise just insert a space
		else{
			cursor.clearSelection();
			cursor.insertText(SPACE);
		}
		autoCompleteMode = false;
		*isHandled = true;
		setTextCursor(cursor);
	}
}

void CommandBar::handleKeyDelete(bool *isHandled){
	TURN_OFF_AC
	//if cursor is within ``, like `<cursor>`, delete both ``
	if(isWithinPairOfQuoteLeft() && hasQuoteLeft_RHS() && hasQuoteLeft_LHS())
		clearCharLHS();
}

void CommandBar::handleKeyBackspace(bool *isHandled){
	TURN_OFF_AC
	//if cursor is within ``, like `<cursor>`, delete both ``
	if(isWithinPairOfQuoteLeft() && hasQuoteLeft_RHS() && hasQuoteLeft_LHS())
		clearCharRHS();
}

void CommandBar::handleKeyLeftOrRight(){
	autoCompleteMode = false;
}

//handle user input history
//refer to pushCurrentLine
void CommandBar::handleKeyUp(){
	if(!inputHistory_undo.isEmpty()){
		QString lastInput = inputHistory_undo.pop();
		inputHistory_redo.push(lastInput);
		clear();
		TEXT_EDIT_BEGIN
		insertHtml(inputHistory_redo.top());
		TEXT_EDIT_END
	}
}

//handle user input history
//refer to pushCurrentLine
void CommandBar::handleKeyDown(){
	if(!inputHistory_redo.isEmpty()){
		QString prevInput = inputHistory_redo.pop();
		inputHistory_undo.push(prevInput);
		clear();
		if(!inputHistory_redo.isEmpty()){
			TEXT_EDIT_BEGIN
			insertHtml(inputHistory_redo.top());
			TEXT_EDIT_END
		}
		else{
			TEXT_EDIT_BEGIN
			insertHtml(EMPTY);
			TEXT_EDIT_END
		}
	}
}

void CommandBar::handleKeyDefault(){
	TURN_ON_AC
}

void CommandBar::mousePressEvent(QMouseEvent *event){
	autoCompleteMode = false;
	QTextEdit::mousePressEvent(event);
}

//create a hotkey template according to templateStr
//hotkey template is a quite useful feature that inserts the templateStr for user,
//then the user can use tab/shift-tab to go thru any blanks and start typing, without
//need to type all the sentence
//btw, blank is defined as "__[A-Z]+__"
void CommandBar::createTemplate(QString templateStr){
	pushCurrentLine();
	TEXT_EDIT_BEGIN
	insertPlainText(templateStr);
	TEXT_EDIT_END
	moveCursor(QTextCursor::Start);
	lastTimeCursor = document()->find(hotkeyTemplate, textCursor());
	if(!lastTimeCursor.isNull())
		setTextCursor(lastTimeCursor);
	hotkeyTemplateMode = true;
}

void CommandBar::createTemplateAdd(){
	createTemplate(HOTKEY_TEMPLATE_ADD);
}

void CommandBar::createTemplateAddTimed(){
	createTemplate(HOTKEY_TEMPLATE_ADD_TIMED);
}

void CommandBar::createTemplateModDone(){
	createTemplate(HOTKEY_TEMPLATE_MOD_DONE);
}

void CommandBar::createTemplateModByName(){
	createTemplate(HOTKEY_TEMPLATE_MOD_BY_NAME);
}

void CommandBar::createTemplateModByIndex(){
	createTemplate(HOTKEY_TEMPLATE_MOD_BY_INDEX);
}

void CommandBar::createTemplateDelByName(){
	createTemplate(HOTKEY_TEMPLATE_DEL_BY_NAME);
}

void CommandBar::createTemplateDelByIndex(){
	createTemplate(HOTKEY_TEMPLATE_DEL_BY_INDEX);
}

void CommandBar::createTemplateFind(){
	createTemplate(HOTKEY_TEMPLATE_FIND);
}

void CommandBar::createTemplateUndo(){
	createTemplate(HOTKEY_TEMPLATE_UNDO);
}

void CommandBar::createTemplateRedo(){
	createTemplate(HOTKEY_TEMPLATE_REDO);
}

//in quick add window, only template add is allowed
void CommandBar::setQuickAddMode(){
	modifyDone->setEnabled(false);
	modifyByName->setEnabled(false);
	modifyByIndex->setEnabled(false);
	delByName->setEnabled(false);
	delByIndex->setEnabled(false);
	find->setEnabled(false);
	undo->setEnabled(false);
	redo->setEnabled(false);
}

	// End of segment: C:\Users\a0102016\Desktop\asd\CommandBar.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\Highlighter.cpp
	 */

const char* Highlighter::COLOR_BLACK                 = "#232323";
const char* Highlighter::COLOR_BLUE                  = "#397CD4";
const char* Highlighter::COLOR_GRAY                  = "#787878";
const char* Highlighter::COLOR_PURPLE                = "#742894";
const char* Highlighter::REGEX_COMMAND               = "^(add|mod|del|find|undo|redo)";
const char* Highlighter::REGEX_KEYWORD               = " exact| name| by| due| from| to| location|"\
										 "place| at| with| ppl| note| priority| impt"\
	"| remind| rt| overdue| done| undone| deadline| timed| floating| #| -by| -due"\
	"| -from| -to| -with(all|[^a])| -ppl(all|[^a])| -remind(all|[^a])| -rt(all|[^a])|"\
	"-#| \\+with| \\+ppl| \\+remind| \\+rt| \\+#";
const char* Highlighter::REGEX_QUOTE_LEFT_PAIRS      = "`(.*)`";
const char* Highlighter::REGEX_HOTKEY_TEMPLATE_BLANK = "__[A-Z]+__";

Highlighter::Highlighter(QTextDocument *parent)
:QSyntaxHighlighter(parent){
	setupFormat();
	setupRegex();
}

//this function will be called by commandBar to highlight the command and keyword
void Highlighter::highlightPatterns(const QString &text){
	for(int i = 0; i < regexForType.size(); i++){//foreach regex
		const QRegExp &regex = regexForType[i];
		int index = regex.indexIn(text);
		while (index > -1) {//foreach regex's occurrence
			int length = regex.matchedLength();
			if (i == COMMAND)
				setFormat(index, length, CommandFormat);
			else if (i == KEYWORD)
				setFormat(index, length, KeywordFormat);
			else if (i == PAIR_QUOTE_LEFT)
				setFormat(index, length, PairOfQuoteLeftFormat);
			else if (i == BLANK)
				setFormat(index, length, BlankFormat);
			index = regex.indexIn(text, index + length);
		}
	}
}

void Highlighter::setupFormat(){
	//CommandFormat
	CommandFormat.setFontWeight(QFont::Bold);
	CommandFormat.setForeground(QBrush(COLOR_BLACK));
	//KeywordFormat
	KeywordFormat.setFontWeight(QFont::Bold);
	KeywordFormat.setForeground(QBrush(COLOR_BLUE));
	//PairOfQuoteLeftFormat
	PairOfQuoteLeftFormat.setFontWeight(QFont::Bold);
	PairOfQuoteLeftFormat.setForeground(QBrush(COLOR_GRAY));
	//BlankFormat
	BlankFormat.setFontWeight(QFont::Bold);
	BlankFormat.setForeground(QBrush(COLOR_PURPLE));
}

void Highlighter::setupRegex(){
	addRegex(COMMAND, REGEX_COMMAND);
	addRegex(KEYWORD, REGEX_KEYWORD);
	addRegex(PAIR_QUOTE_LEFT, REGEX_QUOTE_LEFT_PAIRS);
	addRegex(BLANK, REGEX_HOTKEY_TEMPLATE_BLANK);
}

void Highlighter::addRegex(HIGHLIGHT_TYPE type, const QString &pattern, bool minimal){
	QRegExp regex(pattern);
	regex.setPatternSyntax(QRegExp::RegExp2);
	regex.setMinimal(minimal);
	regexForType.push_back(regex);
}
	// End of segment: C:\Users\a0102016\Desktop\asd\Highlighter.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\ListItemDelegate.cpp
	 */

const int ListItemDelegate::_1ST_COLUMN = 0;
const int ListItemDelegate::_2ND_COLUMN = 1;
const int ListItemDelegate::_3RD_COLUMN = 2;
const QColor ListItemDelegate::WHITE_COLOR = "#ffffff";
const QColor ListItemDelegate::RED_COLOR = "#FFB4B9";
const QColor ListItemDelegate::ORANGE_COLOR = "#FDEBA3";
const QString ListItemDelegate::FONT_SEGOE_UI = QStringLiteral("Segoe UI");

ListItemDelegate::ListItemDelegate( TP::PRIORITY priority, TP::TASK_STATE state, QObject *parent /*= 0*/ ) : QStyledItemDelegate(parent){
	_taskState = state;
	_taskPriority = priority;
}

//make the task align right, normally for the last column
void ListItemDelegate::alignRight( const QModelIndex &index, QPainter * painter, QStyleOptionViewItemV4 &opt ) const{
	const int DESIRED_FONT_SIZE = 15;
	const int X_PT1 = 18, Y_PT1 = 0, X_PT2 = -18, Y_PT2 = -3;
	
	QString displayText = index.data().toString();
	QTextOption alignment(Qt::AlignRight | Qt::AlignVCenter);
	QFont font;
	font.setFamily(FONT_SEGOE_UI);
	font.setPixelSize(DESIRED_FONT_SIZE);
	QRect drawingRegion = opt.rect;
	drawingRegion = drawingRegion.adjusted(X_PT1, Y_PT1, X_PT2, Y_PT2);
	painter->setFont(font);
	painter->setPen(WHITE_COLOR);
	painter->drawText(drawingRegion, displayText, alignment);
}

//paint a strike out, normally for the task name's column
void ListItemDelegate::paintStrikeOut( QPainter * painter, QStyleOptionViewItemV4 &opt ) const{
	const int X_PT1 = 5, Y_PT1 = 24, X_PT2 = -5, Y_PT2 = -24;

	QRect drawingRegion = opt.rect;
	drawingRegion.adjust(X_PT1, Y_PT1, X_PT2, Y_PT2);
	painter->setPen(WHITE_COLOR);
	painter->setBrush(QBrush(WHITE_COLOR));
	painter->drawRect(drawingRegion);
}

//paint a high priority bar at the left hand side corner, normally for the high priority task
void ListItemDelegate::paintHighPrioBar( QPainter * painter, QStyleOptionViewItemV4 &opt ) const{
	const int X_PT1 = -5, Y_PT1 = 0, X_PT2 = -52, Y_PT2 = -2;

	QRect drawingRegion = opt.rect;
	drawingRegion.adjust(X_PT1, Y_PT1, X_PT2, Y_PT2);
	painter->setPen(RED_COLOR);
	painter->setBrush(QBrush(RED_COLOR));
	painter->drawRect(drawingRegion);
}

//paint a "!!", normally for the overdue task
void ListItemDelegate::paintForOverdue( QPainter * painter ) const{
	const int DESIRED_FONT_SIZE = 18;
	const int X_PT1 = 0, Y_PT1 = 0, X_PT2 = 0, Y_PT2 = -2;
	QString displayTextForOVERDUE = "!!";
	
	QTextOption alignment(Qt::AlignLeft | Qt::AlignVCenter);
	QFont font;
	font.setFamily(FONT_SEGOE_UI);
	font.setPixelSize(DESIRED_FONT_SIZE);
	QRect drawingRegion = _opt.rect;
	drawingRegion = drawingRegion.adjusted(X_PT1, Y_PT1, X_PT2, Y_PT2);
	painter->setFont(font);
	painter->setPen(WHITE_COLOR);
	painter->drawText(drawingRegion, displayTextForOVERDUE, alignment);
}

//paint a medium priority bar at the left hand side corner, normally for the medium priority task
void ListItemDelegate::paintMediumPrioBar( QPainter * painter ) const{
	const int X_PT1 = -5, Y_PT1 = 0, X_PT2 = -52, Y_PT2 = -2;

	QRect drawingRegion = _opt.rect;
	drawingRegion.adjust(X_PT1, Y_PT1,X_PT2,Y_PT2);
	painter->setPen(ORANGE_COLOR);
	painter->setBrush(QBrush(ORANGE_COLOR));
	painter->drawRect(drawingRegion);
}

void ListItemDelegate::setupPainting( const QStyleOptionViewItem & option, const QModelIndex & index, QPainter * painter ) const{
	_opt = option;
	initStyleOption(&_opt, index);
	
	//make the dot-dot rectangle disappear, when select
	if (_opt.state & QStyle::State_HasFocus)
		_opt.state = _opt.state ^ QStyle::State_HasFocus;
	//paint css's style first
	QStyledItemDelegate::paint(painter, _opt, index);
}

//must have this function
//which will be called by MainWindow
void ListItemDelegate::paint( QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index ) const{
	setupPainting(option, index, painter);
	painter->save();
	if(index.column() == _1ST_COLUMN && _taskPriority == TP::HIGH)
		paintHighPrioBar(painter, _opt);
	else if(index.column() == _1ST_COLUMN && _taskPriority == TP::MEDIUM)
		paintMediumPrioBar(painter);
	else if(index.column() == _2ND_COLUMN && _taskState == TP::DONE)
		paintStrikeOut(painter, _opt);
	else if(index.column() == _2ND_COLUMN && _taskState == TP::OVERDUE)
		paintForOverdue(painter);
	else if(index.column() == _3RD_COLUMN)
		alignRight(index, painter, _opt);
	painter->restore();
}

	// End of segment: C:\Users\a0102016\Desktop\asd\ListItemDelegate.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\MainWindow.cpp
	 */

using namespace std;
using namespace TP;

const double MainWindow::DESIRED_TRANSPARENT_OPACITY	= 0.4;
const int   MainWindow::LENGTH_TOO_LONG					= 77;
const int   MainWindow::STEP							= 1;
const char* MainWindow::MIDNIGHT						= "00:00";
const char* MainWindow::DELIMITTER						= ", ";
const char* MainWindow::NEGLECTED						= "...";
const char* MainWindow::TODAY_VIEW						= "Today";
const char* MainWindow::INBOX_VIEW						= "Inbox";
const char* MainWindow::REMINDERS_VIEW					= "Reminders";
const char* MainWindow::DATE_DD_MM						= "dd/MM";
const char* MainWindow::DATE_DD_MM_YY					= "dd/MM/yy";
const char* MainWindow::DATE_DD_MM_YYYY					= "dd/MM/yyyy";
const char* MainWindow::DATE_HH_MM						= "hh:mm";
const char* MainWindow::DATE_DD_MM_HH_MM				= "dd/MM hh:mm";
const char* MainWindow::DATE_DD_MM_YYYY_HH_MM			= "dd/MM/yyyy hh:mm";
const char* MainWindow::DATE_YEAR						= "yyyy";
const char* MainWindow::EMPTY                           = "";
const char* MainWindow::DUE_STR							= "Due ";
const char* MainWindow::FROM_STR						= "From ";
const char* MainWindow::TO_STR							= "To ";
const char* MainWindow::FROM_TO_STR						= " to ";
const char* MainWindow::NEW_LINE                        = "\n";
const char* MainWindow::DEFAULT_WIN_TITLE               = "TaskPad";
const char* MainWindow::DEFAULT_STATUS_BAR_TEXT         = "Ready";
const char* MainWindow::DEFAULT_DETAILS_VIEW_TEXT       = "Task's Details";
const char* MainWindow::SUCCESS_DETAILS_ADD_TEXT        = "Added Task's Details";
const char* MainWindow::SUCCESS_DETAILS_MOD_TEXT        = "Modified Task's Details";
const char* MainWindow::SUCCESS_DETAILS_DEL_TEXT        = "Deleted Task's Details";
const char* MainWindow::SUCCESS_DETAILS_UNDO_TEXT       = "Undo Task's Details";
const char* MainWindow::SUCCESS_DETAILS_REDO_TEXT       = "Redo Task's Details";
const char* MainWindow::SUCCESS_STATUS_BAR_ADD_TEXT     = "Task added successfully";
const char* MainWindow::SUCCESS_STATUS_BAR_DEL_TEXT     = "Task deleted successfully";
const char* MainWindow::SUCCESS_STATUS_BAR_MOD_TEXT     = "Task modified successfully";
const char* MainWindow::SUCCESS_STATUS_BAR_FIND_TEXT    = "Searched successfully";
const char* MainWindow::SUCCESS_STATUS_BAR_UNDO_TEXT    = "Undo successfully";
const char* MainWindow::SUCCESS_STATUS_BAR_REDO_TEXT    = "Redo successfully";
const char* MainWindow::SUCCESS_STATUS_BAR_DISPLAY_TEXT = "Task displayed successfully";
const char* MainWindow::SUCCESS_NAV_LABEL_FIND_CMD		= "Search Results";
const char* MainWindow::INTERMEDIATE_NAV_LABEL_INTERMEDIATE_STAGE = "Select a task by typing its index";
const char* MainWindow::INTERMEDIATE_STATUS_BAR_INTERMEDIATE_STAGE = "Multiple results were found";
const char* MainWindow::ERROR_NAV_LABLE_INTERMEDIATE_STAGE = "Select a task by typing its index";
const char* MainWindow::ERROR_STATUS_BAR_INTERMEDIATE_STAGE = "Wrong input. Kindly press ECS to cancel";
const char* MainWindow::ERROR_ONLY_SUPPORT_ADD_N_DISPLAY_ONE_CMD = "Only Add Command and Display 1 are supported";

/************************************************************************/
/*                        INITIALIZATION                                */
/************************************************************************/

MainWindow::MainWindow(QWidget *parent)
:QMainWindow(parent){
	logStart();

	setupUI();
	setupDependency();
	getToday();
}

void MainWindow::setupUI(){
	ui.setupUi(this);
	customisedUi();
	installEventFilter();
}


//************************************
// Method: customisedUi
// Description: 1. make window metro
// style (borderless). 2. beautify tasklist
// column width
//************************************
void MainWindow::customisedUi(){
	const int _1ST_COLUMN = 0;
	const int _2ND_COLUMN = 1;
	const int DESIRED_1ST_COL_WIDTH = 70;
	const int DESIRED_2ND_COL_WIDTH = 220;

	detailsViewOpacity = DESIRED_TRANSPARENT_OPACITY;
	//make window frameless and background transparent
	this->setWindowFlags(Qt::FramelessWindowHint);
	this->setAttribute(Qt::WA_TranslucentBackground, true);

	ui.errorBgWidget->setHidden(true);
	ui.TaskList->header()->resizeSection(_1ST_COLUMN, DESIRED_1ST_COL_WIDTH);
	ui.TaskList->header()->resizeSection(_2ND_COLUMN, DESIRED_2ND_COL_WIDTH);
}

void MainWindow::installEventFilter(){
	ui.CloseButton->installEventFilter(this);
	ui.MinimizeButton->installEventFilter(this);
	ui.HelpButton->installEventFilter(this);
	ui.AboutButton->installEventFilter(this);
	ui.cmdBar->installEventFilter(this);
	ui.TaskList->installEventFilter(this);
}

void MainWindow::setupDependency(){
	setupTimer();
	setupTrayIcon();
	setupConnection();
	setupHotkeys();
	setupScheduler();
}

//Timer will be deleted by its parent (MainWindow) automatically
//DONT DELETE IT! otherwise you will delete it twice and abort the app
void MainWindow::setupTimer(){
	const int CYCLE_ONE_MIN = 60000;
	timer = new QTimer(this);
	timer->start(CYCLE_ONE_MIN);
}

void MainWindow::setupTrayIcon(){
	const char* TRAY_ICON_PATH = ":/MainWindow/Resources/logo.png";
	isQuickAddOpen = false;

	trayIcon = new QSystemTrayIcon(this);
	trayIcon->setIcon(QIcon(TRAY_ICON_PATH));
	trayIcon->show();
	trayIcon->setToolTip(DEFAULT_WIN_TITLE);
}

void MainWindow::setupConnection(){
	//call showReminder every 60 sec
	connect(timer, SIGNAL(timeout()),this, SLOT(showReminder()));
	//handleShowReminder when try msgbox is clicked in reminder mode
	connect(trayIcon, SIGNAL(messageClicked()),this, SLOT(handleShowReminder()));
	//show mainwindow when click tray icon
	connect(trayIcon, SIGNAL(activated(QSystemTrayIcon::ActivationReason)), this, 
		SLOT(iconIsActived(QSystemTrayIcon::ActivationReason)));
	//close mainwindow when click close button
	connect(ui.CloseButton, SIGNAL(clicked()), this, SLOT(close()));
	//minimize mainwindow when click minimum button
	connect(ui.MinimizeButton, SIGNAL(clicked()), this, SLOT(showMinimized()));
	//show about window
	connect(ui.AboutButton, SIGNAL(clicked()), this, SLOT(about()));
	//show help window
	connect(ui.HelpButton, SIGNAL(clicked()), this, SLOT(help()));
	//handle selected task in the list
	connect(ui.TaskList, SIGNAL(itemSelectionChanged()), this, SLOT(handleListSelection()));
}

void MainWindow::setupHotkeys(){
	setupGlobalHotkeys();
	setupWinDisplayHotkeys();
	setupDateNavHotkeys();
}

//scOpenQuickAddWin will be deleted automatically by Qt
//DONT DELETE scOpenQuickAddWin! otherwise you will delete it twice and abort the app
void MainWindow::setupGlobalHotkeys(){
	const char* OPEN_QUICK_ADD_WIN = "Alt+`";
	const char* OPEN_MAIN_WIN = "Ctrl+Alt+t";
	QxtGlobalShortcut * scOpenQuickAddWin = new QxtGlobalShortcut(QKeySequence(OPEN_QUICK_ADD_WIN), this);
	connect(scOpenQuickAddWin, SIGNAL(activated()),this, SLOT(showQuickAddWindow()));
	QxtGlobalShortcut * scOpenMainWin = new QxtGlobalShortcut(QKeySequence(OPEN_MAIN_WIN), this);
	connect(scOpenMainWin, SIGNAL(activated()),this, SLOT(showWindow()));
}

//all QShortcut will be deleted automatically by Qt
//DONT DELETE THEM! otherwise you will delete them twice and abort the app
void MainWindow::setupWinDisplayHotkeys(){
	const char* SHOW_REMINDER_RIGHT_NOW = "F5";
	const char* MINIMIZE_MAIN_WIN = "Ctrl+H";
	const char* SHOW_TODAY_1 = "Ctrl+T";
	const char* SHOW_TODAY_2 = "Alt+1";
	const char* SHOW_INBOX_1 = "Ctrl+I";
	const char* SHOW_INBOX_2 = "Alt+2";
	(void) new QShortcut(QKeySequence(SHOW_REMINDER_RIGHT_NOW), this, SLOT(showReminder()));
	(void) new QShortcut(QKeySequence(MINIMIZE_MAIN_WIN), this, SLOT(showMinimized()));
	(void) new QShortcut(QKeySequence(SHOW_TODAY_1), this, SLOT(getToday()));
	(void) new QShortcut(QKeySequence(SHOW_TODAY_2), this, SLOT(getToday()));
	(void) new QShortcut(QKeySequence(SHOW_INBOX_1), this, SLOT(getInbox()));
	(void) new QShortcut(QKeySequence(SHOW_INBOX_2), this, SLOT(getInbox()));
}

//all QShortcut will be deleted automatically by Qt
//DONT DELETE THEM! otherwise you will delete them twice and abort the app
void MainWindow::setupDateNavHotkeys(){
	const char* SHOW_NEXT_DAY = "Alt+D";
	const char* SHOW_NEXT_WEEK = "Alt+W";
	const char* SHOW_NEXT_MONTH = "Alt+M";
	const char* SHOW_PREV_DAY = "Alt+Shift+D";
	const char* SHOW_PREV_WEEK = "Alt+Shift+W";
	const char* SHOW_PREV_MONTH = "Alt+Shift+M";
	(void) new QShortcut(QKeySequence(SHOW_NEXT_DAY), this, SLOT(showNextDay()));
	(void) new QShortcut(QKeySequence(SHOW_PREV_DAY), this, SLOT(showPrevDay()));
	(void) new QShortcut(QKeySequence(SHOW_NEXT_WEEK), this, SLOT(showNextWeek()));
	(void) new QShortcut(QKeySequence(SHOW_PREV_WEEK), this, SLOT(showPrevWeek()));
	(void) new QShortcut(QKeySequence(SHOW_NEXT_MONTH), this, SLOT(showNextMonth()));
	(void) new QShortcut(QKeySequence(SHOW_PREV_MONTH), this, SLOT(showPrevMonth()));
}


//************************************
// Method:    setupScheduler
// Note: Business logic setup here
//************************************
void MainWindow::setupScheduler(){
	scheduler = new Manager();
}

//************************************
// Method:    setupQuickAddWindow
// Note: **no need to delete quickAddWindowPtr,
// it will be deleted automatically. Otherwise
// abort, since delete twice!**
//************************************
void MainWindow::setupQuickAddWindow(){
	quickAddWindowPtr = new QuickAddWindow();
	quickAddWindowPtr->setAttribute(Qt::WA_DeleteOnClose);
}

void MainWindow::setupQuickAddConnection(){
	QuickAddWindow *qa = (QuickAddWindow*) quickAddWindowPtr;
	connect(qa, SIGNAL(windowClosed()), this, SLOT(closeQuickAddWindow()));
	connect(qa, SIGNAL(requestSubmitted(QString)), this, SLOT(handleQuickAddRequest(QString)));
}

/************************************************************************/
/*                            DESTRUCTOR                                */
/************************************************************************/

MainWindow::~MainWindow(){
	logEnd();
	dispose();
}

void MainWindow::dispose(){
	//must hide trayIcon before window exits
	trayIcon->hide();
	delete scheduler;
	scheduler = NULL;
}

void MainWindow::closeQuickAddWindow(){
	disposeQuickAddWindow();
}

void MainWindow::disposeQuickAddWindow(){
	disposeQuickAddConnection();
	quickAddWindowPtr->close();
	setIsQuickAddOpen(false);
}

//must disconnect when quit the quick add window
void MainWindow::disposeQuickAddConnection(){
	QuickAddWindow *qa = (QuickAddWindow*) quickAddWindowPtr;
	disconnect(qa, SIGNAL(windowClosed()), this, SLOT(closeQuickAddWindow()));
	disconnect(qa, SIGNAL(requestSubmitted(QString)), this, SLOT(handleQuickAddRequest(QString)));
}

/************************************************************************/
/*                        WINDOW DISPLAY                                */
/************************************************************************/

void MainWindow::iconIsActived(QSystemTrayIcon::ActivationReason){
	showWindow();
}

void MainWindow::showWindow(){
	show();
	setWindowState(Qt::WindowActive);
	ui.cmdBar->setFocus();
}

void MainWindow::showReminder(){
	QString output;
	list<Task> reminderList = scheduler->getCurrentReminders();
	if(!reminderList.empty()){
		setCurrRemindTime();
		output = prepareTrayMsg(reminderList, output);
		showTrayMsg(output, REMINDERS_VIEW);
		setFromReminder(true);
	}
}

QString MainWindow::prepareTrayMsg(list<Task> &reminderList, QString output){
	const char* FIRST_ONE = "1. ";
	const char* SPLITTER = ". ";

	list<Task>::iterator iter = reminderList.begin();
	output += FIRST_ONE;
	output += iter->getName().c_str();
	advance(iter, STEP);
	for(int i = 2; 
		iter != reminderList.end();
		advance(iter, STEP), i++){
		output += NEW_LINE;
		output += QString::number(i) + SPLITTER;
		output += iter->getName().c_str();
	}
	return output;
}

void MainWindow::showQuickAddWindow(){
	if(!isQuickAddOpen){
		setIsQuickAddOpen(true);
		setupQuickAddWindow();
		setupQuickAddConnection();
		quickAddWindowPtr->show();
	}
}

void MainWindow::showNextDay(){
	const char* NEXT_DAY_STR = "Next Day: ";
	handleDateNavigation(DAY, NEXT_DAY_STR);
}

void MainWindow::showNextWeek(){
	const char* NEXT_WEEK_STR = "Next Week: ";
	handleDateNavigation(WEEK, NEXT_WEEK_STR);
}

void MainWindow::showNextMonth(){
	const char* NEXT_MONTH_STR = "Next Month: ";
	handleDateNavigation(MONTH, NEXT_MONTH_STR);
}

void MainWindow::showPrevDay(){
	const char* PREV_DAY_STR = "Prev. Day: ";
	handleDateNavigation(DAY, PREV_DAY_STR, true);
}

void MainWindow::showPrevWeek(){
	const char* PREV_WEEK_STR = "Prev. Week: ";
	handleDateNavigation(WEEK, PREV_WEEK_STR, true);
}

void MainWindow::showPrevMonth(){
	const char* PREV_MONTH_STR = "Prev. Month: ";
	handleDateNavigation(MONTH, PREV_MONTH_STR, true);
}

void MainWindow::showTrayMsg(QString msg, QString title){
	isFromReminder = false;
	trayIcon->showMessage(title, msg);
}

void MainWindow::about(){
	const QString DESCRIPTION = \
		"<b>TaskPad</b> is a simple, elegant and revolutionary task organiser designed specifically for power users. " 
		"It empowers the user with 4 basic yet comprehensive functions to Add, Modify, Find and Delete tasks. " 
		"Add and Modify offer a comprehensive list of parameters that neatly catalogues the specifications of" 
		"the tasks while Find is a flexible tool that can retrieve a task according to any of its parameters. "
		"Delete is just a one-line wonder that performs what it is meant to do. TaskPad also has Hot Key Templating: " 
		"all 4 functions are made simple with intuitive hotkeys that calls the full command template with clear " 
		"instructions.<br /><br />"
		"<b>TaskPad Team</b>: ASHRAY JAIN, XIE KAI, AN JIANGZE, THYAGESH M., LI ZIXUAN.";
	popMsgBox(DEFAULT_WIN_TITLE, DESCRIPTION);
}

void MainWindow::help(){
	const QString HOTKEY_LIST = \
		"<b>Commands</b><br />"
		"add, mod, del, find, undo, redo<br /><br />"
		"<b>Global Hotkeys</b><br />"
		"Alt + ` 			        : open quick add window<br />"
		"Ctrl + Alt + T 		    : open main window<br />"
		"<br />"
		"<b>Local Hotkeys</b><br />"
		"<b>Quick Add window</b><br />"
		"ESC			            : exit window<br />"
		"<br />"
		"<b>Mainwindow</b><br />"
		"Ctrl + H 		            : hide main window<br />"
		"Ctrl + T 		            : show Today's view<br />"
		"Ctrl + I			        : show Inbox's view<br />"
		"Alt + 1 			        : show Today's view<br />"
		"Alt + 2 			        : show Inbox's view<br />"
		"// Date Navigation<br />"
		"Alt + D 		            : show next day<br />"
		"Alt + Shift + D 		    : show prev. day<br />"
		"Alt + W 		            : show next week<br />"
		"Alt + Shift + W 	        : show prev. day<br />"
		"Alt + M 		            : show next month<br />"
		"Alt + Shift + M 		    : show prev. month<br />"
		"<br />"
		"<b>CommandBar</b><br />"
		"// Hotkey Template<br />"
		"Ctrl + N		            : new deadline task<br />"
		"Ctrl + Shift + N 	        : new timed task<br />"
		"Ctrl + M 		            : modify task as done<br />"
		"Ctrl + Shift + M 	        : modify task by index<br />"
		"Ctrl + Alt + Shift + M 	: modify task by name<br />"
		"Ctrl + D 		            : delete task by index<br />"
		"Ctrl + Shift + D 	        : delete task by name<br />"
		"Ctrl + F 		            : find task<br />"
		"Ctrl + U 		            : undo<br />"
		"Ctrl + R 		            : redo<br />"
		"Tab/Space 		            : auto complete<br />"
		"<br />"
		"// in HotKey Template mode<br />"
		"Tab 			            : jump to next blank<br />"
		"Shift + Tab 		        : jump to prev. blank;<br /><br />"
		"For more information, kindly refer to our<br />"
		"<a href=\"http://bit.ly/HEdCw4\">Project Manual</a>";
	popMsgBox(DEFAULT_WIN_TITLE, HOTKEY_LIST);
}

void MainWindow::popMsgBox(QString title, QString description){
	QMessageBox msgBox;
	msgBox.setWindowTitle(title);
	msgBox.setText(description);
	msgBox.exec();
}

/************************************************************************/
/*                              HANDLERS                                */
/************************************************************************/

void MainWindow::getToday(){
	reset();
	//cannot be in the Intermediate stage
	assert(!isIntermediateStage);
	Messenger msg = scheduler->getTodayTasks();
	handleGetToday(msg);
}

void MainWindow::getInbox(){
	const char* GET_INBOX_CMD_STR = "find floating undone";
	reset();
	//cannot be in the Intermediate stage
	assert(!isIntermediateStage);
	Messenger msg = scheduler->processCommand(GET_INBOX_CMD_STR);
	handleGetInbox(msg);
}


//************************************
// Method:    reset
// Note: to avoid influence from Intermediate
// stage, we will call this function
//************************************
void MainWindow::reset(){
	scheduler->resetStatus();
	ui.cmdBar->clear();
	isIntermediateStage = false;
}

void MainWindow::handleDateNavigation(TP::PERIOD_TYPE periodType, QString listTitle, bool isPrevious){
	Messenger msg;
	if(isPrevious)
		msg = scheduler->getPrevPeriodTasks(periodType);
	else
		msg = scheduler->getNextPeriodTasks(periodType);

	pair<tm, tm> period;
	switch (msg.getStatus()){
	case SUCCESS:
		period = scheduler->getCurrentPeriod();
		listTitle += getTimePeriodStr(period);
		updateMainView(msg, listTitle);
		handleOneItemList(msg);
		break;
	case ERR:
		handleMsg_ERROR(msg);
		break;
	}
}

//************************************
// Method:    getTimePeriodStr
// Note: result of this will be used in
// date navigation
//************************************
QString MainWindow::getTimePeriodStr(pair<tm, tm> period){
	const char* SPLITTER = " - ";
	QDateTime fromDate = QDateTime::fromTime_t(mktime(&period.first));
	QDateTime toDate = QDateTime::fromTime_t(mktime(&period.second));
	QString fromStr = fromDate.toString(DATE_DD_MM_YYYY);
	QString toStr = toDate.toString(DATE_DD_MM_YYYY);
	return fromStr + SPLITTER + toStr;
}

void MainWindow::handleGetToday(Messenger msg){
	updateMainView(msg, TODAY_VIEW);
}

void MainWindow::handleGetInbox(Messenger msg){
	updateMainView(msg, INBOX_VIEW);
}

void MainWindow::handleQuickAddRequest(QString requestStr){
	if(isCommandAdd(requestStr) || isEqualOne(requestStr)){
		getToday();
		Messenger msg = scheduler->processCommand(requestStr.toStdString());
		switch (msg.getStatus()){
		case TP::ERR:
			handleQA_ERROR(requestStr, msg);
			break;
		case TP::SUCCESS:
			handleQA_SUCCESS();
			break;
		case TP::DISPLAY:
			handleQA_DISPLAY(msg);
			break;
		}
	}
	else
		showTrayMsg(ERROR_ONLY_SUPPORT_ADD_N_DISPLAY_ONE_CMD);
}


//************************************
// Method:    isCommandAdd
// Note: only allow cmd add for quick 
// add window
//************************************
bool MainWindow::isCommandAdd(QString requestStr){
	const int CANT_FIND = -1;
	const QString COMMAND_ADD = "^add.*";
	const QRegExp REGEX_CMD_ADD(COMMAND_ADD);
	return REGEX_CMD_ADD.indexIn(requestStr) != CANT_FIND;
}

bool MainWindow::isEqualOne(QString &requestStr){
	return requestStr.toInt() == 1;
}

void MainWindow::handleShowReminder(){
	if(isFromReminder){
		reset();
		//cannot be in the Intermediate stage
		assert(!isIntermediateStage);
		string findCurrRtTasks = getFindRtCmd();
		Messenger msg = scheduler->processCommand(findCurrRtTasks);
		updateMainView(msg, REMINDERS_VIEW);
		handleOneItemList(msg);
		showWindow();
		setFromReminder(false);
	}
}

std::string MainWindow::getFindRtCmd(){
	string currRemindTimeStr = currRemindTime.toString(DATE_DD_MM_YYYY_HH_MM).toStdString();
	const string FIND_CURR_REMIND_TASKS = "find rt `" + currRemindTimeStr + "` undone";
	return FIND_CURR_REMIND_TASKS;
}

void MainWindow::handleMessenger(Messenger msg){
	switch (msg.getStatus()){
	case ERR:
		handleMsg_ERROR(msg);
		break;
	case ERR_INTER:
		handleMsg_ERROR_INTERMEDIATE();
		break;
	case SUCCESS:
		handleMsg_SUCCESS(msg);
		break;
	case INTERMEDIATE:
		handleMsg_INTERMEDIATE(msg);
		break;
	case DISPLAY:
		handleDisplay(msg);
		break;
	case SUCCESS_INDEXED_COMMAND:
		handleMsg_SUCCESS_INDEXED_CMD(msg);
		break;
	}
}

void MainWindow::handleListSelection(){
	QList<QTreeWidgetItem*> list = ui.TaskList->selectedItems();
	if(!list.isEmpty()){
		QTreeWidgetItem* item = ui.TaskList->selectedItems().front();
		int listIndex = ui.TaskList->indexOfTopLevelItem(item);
		int actualIndex = listIndex + 1;
		if(!isIntermediateStage){
			QString indexStr = QString::number(actualIndex);
			Messenger msg = scheduler->processCommand(indexStr.toStdString());
			handleDisplay(msg, true);
		}
		else{//Intermediate Stage
			std::list<Task>::iterator iter = intermediateList.begin();
			advance(iter, listIndex);
			updateDetails(*iter);
		}
	}
}

void MainWindow::unselectAllItems(){
	for(int i = 0; i < ui.TaskList->topLevelItemCount(); i++){
		QTreeWidgetItem* itemToUnselect = ui.TaskList->topLevelItem(i);
		ui.TaskList->setItemSelected(itemToUnselect, false);
	}
}

void MainWindow::selectItemAt( int index ){
	int actualIndex = index;
	int listIndex = actualIndex - 1;
	QTreeWidgetItem* itemToShow = ui.TaskList->topLevelItem(listIndex);
	ui.TaskList->setItemSelected(itemToShow, true);
}

void MainWindow::handleDisplay(Messenger msg, bool callFromSignal){
	int actualIndex = msg.getIndex();
	int listIndex = actualIndex - 1;
	assert(actualIndex > 0);//need be positive and starts from 1

	list<Task> tmp_list = msg.getList();
	list<Task>::iterator iter = tmp_list.begin();
	advance(iter, listIndex);
	//in case of causing loop, check whether from signal event calling
	if(!callFromSignal){
		unselectAllItems();
		selectItemAt(actualIndex);
	}
	updateStatusBar(SUCCESS_STATUS_BAR_DISPLAY_TEXT);
	updateDetailsLabel();
	updateDetails(*iter);
}

void MainWindow::handleQA_ERROR(QString requestStr, Messenger &msg){
	if(!isEqualOne(requestStr)){
		showTrayMsg(msg.getErrorMsg().c_str());
		displayErrorView();
	}
	else{
		closeQuickAddWindow();
		showWindow();
	}
}

void MainWindow::handleQA_SUCCESS(){
	const char* SUCCESS_QA_MSG_ADDED = "Added";
	closeQuickAddWindow();
	refresh();
	showTrayMsg(SUCCESS_QA_MSG_ADDED);
	showReminder();
}

void MainWindow::handleQA_DISPLAY(Messenger msg){
	closeQuickAddWindow();
	handleDisplay(msg);
	showWindow();
}

void MainWindow::handleMsg_ERROR(Messenger &msg){
	updateStatusBar(msg.getErrorMsg().c_str());
	displayErrorView();
}

void MainWindow::handleMsg_ERROR_INTERMEDIATE(){
	updateNavLabel(ERROR_NAV_LABLE_INTERMEDIATE_STAGE);
	updateStatusBar(ERROR_STATUS_BAR_INTERMEDIATE_STAGE);
	displayErrorView();
}

void MainWindow::handleMsg_SUCCESS(Messenger &msg){
	switch(msg.getCommandType()){
	case TP::ADD:
		updateForCmdExec(SUCCESS_STATUS_BAR_ADD_TEXT, SUCCESS_DETAILS_ADD_TEXT, msg);
		showReminder();
		break;
	case TP::DEL:
		updateForCmdExec(SUCCESS_STATUS_BAR_DEL_TEXT, SUCCESS_DETAILS_DEL_TEXT, msg);
		break;
	case TP::MOD:
		updateForCmdExec(SUCCESS_STATUS_BAR_MOD_TEXT, SUCCESS_DETAILS_MOD_TEXT, msg);
		showReminder();
		break;
	case TP::FIND:
		updateMainView(msg, SUCCESS_NAV_LABEL_FIND_CMD, SUCCESS_STATUS_BAR_FIND_TEXT);
		handleOneItemList(msg);
		break;
	case TP::UNDO:
		updateForCmdExec(SUCCESS_STATUS_BAR_UNDO_TEXT, SUCCESS_DETAILS_UNDO_TEXT, msg);
		break;
	case TP::REDO:
		updateForCmdExec(SUCCESS_STATUS_BAR_REDO_TEXT, SUCCESS_DETAILS_REDO_TEXT, msg);
		break;
	}
	isIntermediateStage = false;
}

void MainWindow::handleMsg_INTERMEDIATE(Messenger msg){
	updateMainView(msg, INTERMEDIATE_NAV_LABEL_INTERMEDIATE_STAGE, 
		INTERMEDIATE_STATUS_BAR_INTERMEDIATE_STAGE);
	isIntermediateStage = true;
	intermediateList = msg.getList();
}

void MainWindow::handleMsg_SUCCESS_INDEXED_CMD(Messenger &msg){
	switch (msg.getCommandType()){
	case TP::MOD:
		updateForCmdExec(SUCCESS_STATUS_BAR_MOD_TEXT, SUCCESS_DETAILS_MOD_TEXT, msg);
		showReminder();
		break;
	case TP::DEL:
		updateForCmdExec(SUCCESS_STATUS_BAR_DEL_TEXT, SUCCESS_DETAILS_DEL_TEXT, msg);
		break;
	}
}

void MainWindow::refresh(){
	Messenger refreshedMsg = scheduler->refreshList();
	updateList(refreshedMsg.getList());
}

//************************************
// Method:    handleOneItemList
// Note: if list has only one item,
// display it directly
//************************************
void MainWindow::handleOneItemList(Messenger &msg, QString detailsLabel /*= "Task's Details" */){
	const int ONLY_ONE = 1;
	if(msg.getList().size() == ONLY_ONE){
		msg.setTask(msg.getList().front());
		scheduler->syncTask(msg.getList().front());
		updateDetailsView(msg, detailsLabel);
	}
}

/************************************************************************/
/*                              UPDATERS                                */
/************************************************************************/

void MainWindow::updateNavLabel(QString str){
	if(str != INTERMEDIATE_NAV_LABEL_INTERMEDIATE_STAGE)
		navTitleOfLastTime = str;
	ui.Navigation_taskList->setText(str);
}

void MainWindow::updateDetailsLabel(QString str /*= "Task's Details"*/){
	ui.Navigation_detailsView->setText(str);
}

void MainWindow::updateList(std::list<Task> result){
	QTreeWidgetItem* item = NULL;
	ui.TaskList->clear();
	int count = 1;
	for(std::list<Task>::const_iterator iter = result.begin();
		iter != result.end();
		std::advance(iter, STEP)){
		item = extractTask(count, *iter);
		ui.TaskList->addTopLevelItem(item);
		count++;
	}
}

void MainWindow::updateDetails(Task task){
	setDetailsViewOpacity100();
	setNameLabel(task);
	setPriorityLabel(task);
	setDueOrFromToLabel(task);
	setLocationLabel(task);
	setParticipantsLabel(task);
	setTagsLabel(task);
	setRemindTimesLabel(task);
	setNoteLabel(task);
}

void MainWindow::clearDetails(){
	setDetailsViewOpacity40();
	clearStrikeOut();
	updateDetailsLabel();
	setDetailsViewEmpty();
}

void MainWindow::clearStrikeOut(){
	QFont nameFont = ui.name->font();
	nameFont.setStrikeOut(false);
	ui.name->setFont(nameFont);
}

void MainWindow::updateStatusBar(QString str){
	ui.StatusBar->setText(str);
}

void MainWindow::updateMainView(Messenger &msg, QString listTitle, QString statusBarLabel /*= "Ready" */){
	clearDetails();
	updateStatusBar(statusBarLabel);
	updateNavLabel(listTitle);
	updateList(msg.getList());
}

void MainWindow::updateDetailsView(Messenger &msg, QString label /*= "Task's Details"*/){
	updateDetails(msg.getTask());
	updateDetailsLabel(label);
}

void MainWindow::updateForCmdExec(QString statusBarTxt, QString DetailsLabel, Messenger msg){
	updateNavLabel(navTitleOfLastTime);
	updateStatusBar(statusBarTxt);
	updateDetailsView(msg, DetailsLabel);
	refresh();
}

/************************************************************************/
/*                            EXTRACTORS                                */
/************************************************************************/

QTreeWidgetItem* MainWindow::extractTask(int index, Task task){
	QStringList strList;
	switch (task.getTaskType()){
	case DEADLINE:
		strList = extractDueDate(task, strList, index);
		break;
	case TIMED:
		strList = extractTimedDate(task, strList, index);
		break;
	case FLOATING:
		strList = extractFloating(index, task);
		break;
	}
	setListItemDelegate(task, index);
	return new QTreeWidgetItem(strList);
}

QStringList MainWindow::extractFloating(int index, Task &task){
	return QStringList() << QString::number(index) << task.getName().c_str() << EMPTY;
}

QStringList MainWindow::extractTimedDate(Task &task, QStringList strList, int index){
	QString fromTimeStr, toTimeStr;
	if(task.getFlagFromDate())
		fromTimeStr = getFromTimeStr(task, fromTimeStr);
	if(task.getFlagToDate())
		toTimeStr = getToDateStr(task, toTimeStr);
	strList = QStringList() << QString::number(index) << task.getName().c_str() << \
		fromTimeStr + toTimeStr;
	return strList;
}

QString MainWindow::getFromTimeStr(Task &task, QString fromTimeStr){
	QDateTime fromTime = QDateTime::fromTime_t(task.getFromDate());
	fromTimeStr = FROM_STR;
	if(ui.Navigation_taskList->text() == TODAY_VIEW && 
		fromTime.toString(DATE_DD_MM_YY) == QDateTime::currentDateTime().toString(DATE_DD_MM_YY)){
		fromTimeStr += fromTime.toString(DATE_HH_MM);
	}
	else{
		if(fromTime.toString(DATE_YEAR) == QDateTime::currentDateTime().toString(DATE_YEAR))
			fromTimeStr += fromTime.toString(DATE_DD_MM_HH_MM);
		else
			fromTimeStr += fromTime.toString(DATE_DD_MM_YYYY);
	}
	return fromTimeStr;
}

QString MainWindow::getToDateStr(Task &task, QString toTimeStr){
	QDateTime toTime = QDateTime::fromTime_t(task.getToDate());
	if(task.getFlagFromDate())
		toTimeStr = FROM_TO_STR;
	else
		toTimeStr = TO_STR;
	if(ui.Navigation_taskList->text() == TODAY_VIEW && 
		toTime.toString(DATE_DD_MM_YY) == QDateTime::currentDateTime().toString(DATE_DD_MM_YY)){
		toTimeStr += toTime.toString(DATE_HH_MM);
	}
	else{
		if(toTime.toString(DATE_YEAR) == QDateTime::currentDateTime().toString(DATE_YEAR))
			toTimeStr += toTime.toString(DATE_DD_MM_HH_MM);
		else
			toTimeStr += toTime.toString(DATE_DD_MM_YYYY);
	}
	return toTimeStr;
}

QString MainWindow::getDueDateStr( QDateTime &time, QString dueTimeStr ){
	if(ui.Navigation_taskList->text() == TODAY_VIEW){
		if(time.toString(DATE_HH_MM) != MIDNIGHT)
			dueTimeStr = time.toString(DATE_HH_MM);
		else
			dueTimeStr = QString(TODAY_VIEW).toLower();
	}
	else{
		if(time.toString(DATE_YEAR) == QDateTime::currentDateTime().toString(DATE_YEAR))
			if(time.toString(DATE_HH_MM) != MIDNIGHT)
				dueTimeStr = time.toString(DATE_DD_MM_HH_MM);
			else
				dueTimeStr = time.toString(DATE_DD_MM);
		else
			dueTimeStr = time.toString(DATE_DD_MM_YYYY);
	}
	return dueTimeStr;
}

QStringList MainWindow::extractDueDate(Task &task, QStringList strList, int index){
	QString dueTimeStr;
	QDateTime time = QDateTime::fromTime_t(task.getDueDate());
	dueTimeStr = getDueDateStr(time, dueTimeStr);
	strList = QStringList() << QString::number(index) << task.getName().c_str() << \
		DUE_STR + dueTimeStr;
	return strList;
}

/************************************************************************/
/*                               SETTERS                                */
/************************************************************************/

void MainWindow::setCurrRemindTime(){
	currRemindTime = QDateTime::currentDateTime();
}

void MainWindow::setFromReminder(bool toggle){
	isFromReminder = toggle;
}

void MainWindow::setIsQuickAddOpen(bool toggle){
	isQuickAddOpen = toggle;
}

void MainWindow::setHighPriorityDelegate(int index){
	ui.TaskList->setItemDelegateForRow(index, new ListItemDelegate(HIGH, UNDONE, ui.TaskList));
}

void MainWindow::setHighPriorityDoneDelegate(int index){
	ui.TaskList->setItemDelegateForRow(index, new ListItemDelegate(HIGH, DONE, ui.TaskList));
}

void MainWindow::setHighPriorityOverdueDelegate(int index){
	ui.TaskList->setItemDelegateForRow(index, new ListItemDelegate(HIGH, OVERDUE, ui.TaskList));
}

void MainWindow::setMediumPriorityDelegate(int index){
	ui.TaskList->setItemDelegateForRow(index, new ListItemDelegate(MEDIUM, UNDONE, ui.TaskList));
}

void MainWindow::setMediumPriorityDoneDelegate(int index){
	ui.TaskList->setItemDelegateForRow(index, new ListItemDelegate(MEDIUM, DONE, ui.TaskList));
}

void MainWindow::setMediumPriorityOverdueDelegate(int index){
	ui.TaskList->setItemDelegateForRow(index, new ListItemDelegate(MEDIUM, OVERDUE, ui.TaskList));
}

void MainWindow::setNormalDelegate(int index){
	ui.TaskList->setItemDelegateForRow(index, new ListItemDelegate(LOW, UNDONE, ui.TaskList));
}

void MainWindow::setNormalDoneDelegate(int index){
	ui.TaskList->setItemDelegateForRow(index, new ListItemDelegate(LOW, DONE, ui.TaskList));
}

void MainWindow::setNormalOverdueDelegate(int index){
	ui.TaskList->setItemDelegateForRow(index, new ListItemDelegate(LOW, OVERDUE, ui.TaskList));
}

void MainWindow::setListItemDelegate(Task &task, int index){
	int listIndex = index - 1;
	//for HIGH prio
	setForHighPrioItem(task, listIndex);
	//for MEDIUM
	setForMediumPrioItem(task, listIndex);
	//for LOW
	setForLowPrioItem(task, listIndex);
}

void MainWindow::setForHighPrioItem( Task &task, int listIndex ){
	if     (task.getPriority() == HIGH   && task.getState() == UNDONE)
		setHighPriorityDelegate(listIndex);
	else if(task.getPriority() == HIGH   && task.getState() == DONE)
		setHighPriorityDoneDelegate(listIndex);
	else if(task.getPriority() == HIGH   && task.getState() == OVERDUE)
		setHighPriorityOverdueDelegate(listIndex);
}

void MainWindow::setForMediumPrioItem( Task &task, int listIndex ){
	if     (task.getPriority() == MEDIUM && task.getState() == UNDONE)
		setMediumPriorityDelegate(listIndex);
	else if(task.getPriority() == MEDIUM && task.getState() == DONE)
		setMediumPriorityDoneDelegate(listIndex);
	else if(task.getPriority() == MEDIUM && task.getState() == OVERDUE)
		setMediumPriorityOverdueDelegate(listIndex);
}

void MainWindow::setForLowPrioItem( Task &task, int listIndex ){
	if     (task.getPriority() == LOW && task.getState() == UNDONE)
		setNormalDelegate(listIndex);
	else if(task.getPriority() == LOW && task.getState() == DONE)
		setNormalDoneDelegate(listIndex);
	else if(task.getPriority() == LOW && task.getState() == OVERDUE)
		setNormalOverdueDelegate(listIndex);
}

void MainWindow::setDetailsViewEmpty(){
	setLabelEmpty(ui.name);
	setLabelEmpty(ui.dueOrFromTo);
	setLabelEmpty(ui.location);
	setLabelEmpty(ui.participants);
	setLabelEmpty(ui.tags);
	setLabelEmpty(ui.remindTime);
	setLabelEmpty(ui.note);
}

//************************************
//    SETTERS FOR DETAILS (BELOW)
//************************************
void MainWindow::setDetailsViewOpacity40(){
	const char* PROPERTY_OPACITY = "opacity";
	const int ANIMATE_DURATION = 330;

	QGraphicsOpacityEffect* opacityEffect = new QGraphicsOpacityEffect(this);
	opacityEffect->setOpacity(detailsViewOpacity);
	ui.DetailsView->setGraphicsEffect(opacityEffect);
	QPropertyAnimation *animation = new QPropertyAnimation(opacityEffect, PROPERTY_OPACITY);
	animation->setDuration(ANIMATE_DURATION);
	animation->setStartValue(detailsViewOpacity);
	animation->setEndValue(DESIRED_TRANSPARENT_OPACITY);
	animation->start(QAbstractAnimation::DeleteWhenStopped);
	detailsViewOpacity = DESIRED_TRANSPARENT_OPACITY;
}

void MainWindow::displayErrorView(){
	const char* PROPERTY_OPACITY = "opacity";
	const double NON_TRANSPARENT = 1.0;
	const double TRANSPARENT = 0.0;
	const int ANIMATE_DURATION = 1200;

	QGraphicsOpacityEffect* opacityEffect = new QGraphicsOpacityEffect(this);
	opacityEffect->setOpacity(NON_TRANSPARENT);
	ui.errorBgWidget->setGraphicsEffect(opacityEffect);
	ui.errorBgWidget->setHidden(false);
	QPropertyAnimation *animation = new QPropertyAnimation(opacityEffect, PROPERTY_OPACITY);
	animation->setDuration(ANIMATE_DURATION);
	animation->setStartValue(NON_TRANSPARENT);
	animation->setEndValue(TRANSPARENT);
	animation->start(QAbstractAnimation::DeleteWhenStopped);
}

void MainWindow::setDetailsViewOpacity100(){
	const double NON_TRANSPARENT = 1.0;
	ui.DetailsView->setGraphicsEffect(NULL);
	detailsViewOpacity = NON_TRANSPARENT;
}

void MainWindow::setNameLabel(Task &task){
	const char* OVERDUE_SIGN = "!! ";
	QFont nameFont = ui.name->font();
	nameFont.setStrikeOut(false);

	setLabelText(ui.name, task.getName().c_str());

	if(task.getState() == TP::OVERDUE)
		ui.name->setText(OVERDUE_SIGN + ui.name->text());
	else if(task.getState() == TP::DONE)
		nameFont.setStrikeOut(true);
	ui.name->setFont(nameFont);
}

void MainWindow::setPriorityLabel(Task &task){
	const char* HIGH_PRIO_BG = "QWidget#DetailsView{\n"
		"	background-image:url(:/MainWindow/Resources/details_high_bg.png);\n"
		"}";
	const char* MEDIUM_PRIO_BG = "QWidget#DetailsView{\n"
		"	background-image:url(:/MainWindow/Resources/details_normal_bg.png);\n"
		"}";
	const char* LOW_PRIO_BG = "QWidget#DetailsView{\n"
		"	background-image:url(:/MainWindow/Resources/details_low_bg.png);\n"
		"}";

	switch (task.getPriority()){
	case HIGH:
		ui.DetailsView->setStyleSheet(QLatin1String(HIGH_PRIO_BG));
		break;
	case MEDIUM:
		ui.DetailsView->setStyleSheet(QLatin1String(MEDIUM_PRIO_BG));
		break;
	case LOW:
		ui.DetailsView->setStyleSheet(QLatin1String(LOW_PRIO_BG));
		break;
	}
}

void MainWindow::setDueDateLabel(Task &task){
	QDateTime time = QDateTime::fromTime_t(task.getDueDate());
	if(time.toString(DATE_HH_MM) == MIDNIGHT)
		ui.dueOrFromTo->setText(DUE_STR + time.toString(DATE_DD_MM_YYYY));
	else
		ui.dueOrFromTo->setText(DUE_STR + time.toString(DATE_DD_MM_YYYY_HH_MM));
}

void MainWindow::setTimedLabel(Task &task){
	QString fromTimeStr, toTimeStr;
	if(task.getFlagFromDate()){
		QDateTime fromTime = QDateTime::fromTime_t(task.getFromDate());
		fromTimeStr = FROM_STR + fromTime.toString(DATE_DD_MM_YYYY_HH_MM);
	}
	if(task.getFlagToDate()){
		QDateTime toTime = QDateTime::fromTime_t(task.getToDate());
		if(task.getFlagFromDate())
			toTimeStr = FROM_TO_STR + toTime.toString(DATE_DD_MM_YYYY_HH_MM);
		else
			toTimeStr = TO_STR + toTime.toString(DATE_DD_MM_YYYY_HH_MM);
	}
	ui.dueOrFromTo->setText(fromTimeStr + toTimeStr);
}

void MainWindow::setFloatingLabel(){
	setLabelEmpty(ui.dueOrFromTo);
}

void MainWindow::setDueOrFromToLabel(Task &task){
	switch (task.getTaskType()){
	case DEADLINE:
		setDueDateLabel(task);
		break;
	case TIMED:
		setTimedLabel(task);
		break;
	case FLOATING:
		setFloatingLabel();
		break;
	}
	ui.dueOrFromTo->setToolTip(ui.dueOrFromTo->text());
}

void MainWindow::setLocationLabel(Task &task){
	const char* AT = "@";

	if(task.getFlagLocation())
		setLabelText(ui.location, (AT + task.getLocation()).c_str());
	else
		setLabelEmpty(ui.location);
}

void MainWindow::setParticipantsLabel(Task &task){
	if(task.getFlagParticipants()){
		QString participants;
		list<string> listOfParticipants =  task.getParticipants();
		list<string>::iterator iter = listOfParticipants.begin();
		participants += iter->c_str();
		iter++;
		for(;iter != listOfParticipants.end();
			advance(iter, STEP)){
				participants += DELIMITTER;
				participants += iter->c_str();
		}
		setLabelText(ui.participants, participants);
	}
	else{
		setLabelEmpty(ui.participants);
	}
}

void MainWindow::setTagsLabel(Task &task){
	const char* SHARP = "#";

	if(task.getFlagTags()){
		QString tags;
		list<string> listOfTags = task.getTags();
		list<string>::iterator iter = listOfTags.begin();
		tags += SHARP;
		tags += iter->c_str();
		iter++;
		for(;iter != listOfTags.end();
			advance(iter, STEP)){
				tags += DELIMITTER;
				tags += SHARP;
				tags += iter->c_str();
		}
		setLabelText(ui.tags, tags);
	}
	else{
		setLabelEmpty(ui.tags);
	}
}

void MainWindow::setRemindTimesLabel(Task &task){
	const char* REMIND_ME_STR = "Remind me : ";

	if(task.getFlagRemindTimes()){
		QString remindTimes;
		list<time_t> listOfRemindTimes = task.getRemindTimes();
		list<time_t>::iterator iter = listOfRemindTimes.begin();
		remindTimes += QDateTime::fromTime_t(*iter).toString(DATE_DD_MM_YYYY_HH_MM);
		iter++;
		for(;iter != listOfRemindTimes.end();
			advance(iter, STEP)){
				remindTimes += DELIMITTER;
				remindTimes += QDateTime::fromTime_t(*iter).toString(DATE_DD_MM_YYYY_HH_MM);
		}
		setLabelText(ui.remindTime, REMIND_ME_STR + remindTimes);
	}
	else{
		setLabelEmpty(ui.remindTime);
	}
}

void MainWindow::setLabelText(QLineEdit *label, QString text){
	label->setText(text);
	if(label->text().length() < LENGTH_TOO_LONG)
		label->setToolTip(label->text());
	else
		label->setToolTip(label->text().left(LENGTH_TOO_LONG) + NEGLECTED);
}

void MainWindow::setLabelEmpty(QLineEdit *label){
	label->setText(EMPTY);
	label->setToolTip(EMPTY);
}

void MainWindow::setLabelText(QPlainTextEdit *label, QString text){
	label->setPlainText(text);
	if(label->toPlainText().length() < LENGTH_TOO_LONG)
		label->setToolTip(label->toPlainText());
	else
		label->setToolTip(label->toPlainText().left(LENGTH_TOO_LONG) + NEGLECTED);
}

void MainWindow::setLabelEmpty(QPlainTextEdit *label){
	label->setPlainText(EMPTY);
	label->setToolTip(EMPTY);
}

void MainWindow::setNoteLabel(Task &task){
	if(task.getFlagNote())
		setLabelText(ui.note, task.getNote().c_str());
	else
		setLabelEmpty(ui.note);
}

/************************************************************************/
/*                        WINDOW EVENT RELATED                          */
/************************************************************************/

bool MainWindow::eventFilter(QObject* watched, QEvent* event){
	bool ret = true;
	if(watched == ui.CloseButton || watched == ui.MinimizeButton ||
		watched == ui.HelpButton || watched == ui.AboutButton){
		if(event->type() != QEvent::MouseMove){
			ret = QObject::eventFilter(watched, event);//normal processing
		}
	}
	else if(watched == ui.cmdBar && 
		event->type() == QEvent::KeyPress){
			ret = handleKeyPressInCmdBar(ret, watched, event);
	}
	else{
		ret = QObject::eventFilter(watched, event);//normal processing
	}
	return ret;
}

void MainWindow::keyPressEvent(QKeyEvent* event){
	if(event->modifiers() != Qt::ControlModifier)
		ui.cmdBar->setFocus();
	if(event->key() == Qt::Key_Escape)
		getToday();
	QMainWindow::keyPressEvent(event);
}

void MainWindow::changeEvent(QEvent* event){
	runInBackground(event);
	QMainWindow::changeEvent(event);
}

void MainWindow::runInBackground(QEvent* event){
	const int RIGHT_AWAY = 0;
	if(event->type()==QEvent::WindowStateChange){
		if(windowState() == Qt::WindowMinimized){
			QTimer::singleShot(RIGHT_AWAY, this, SLOT(hide()));
		}
	}
}

//************************************
// Method:    mousePressEvent
// Note: impl darg & move for borderless
// window
//************************************
void MainWindow::mousePressEvent(QMouseEvent *event){
	this->windowPosition = this->pos();
	this->mousePressPosition = event->globalPos();
}

void MainWindow::mouseMoveEvent(QMouseEvent *event){
	this->mouseMovePosition = event->globalPos();
	QPoint distanceToMove = this->mouseMovePosition - this->mousePressPosition + this->windowPosition;
	this->move(distanceToMove);   
}

bool MainWindow::handleKeyPressInCmdBar( bool ret, QObject* watched, QEvent* event ){
	QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
	if(keyEvent->key() == Qt::Key_Escape){
		getToday();
	}
	else if(keyEvent->key() == Qt::Key_Return || keyEvent->key() == Qt::Key_Enter){
		handleKeyEnter();
	}
	else{
		ret = QObject::eventFilter(watched, event);//normal processing
	}
	return ret;
}

void MainWindow::handleKeyEnter(){
	QString currentInput = ui.cmdBar->getCurrentLine();
	ui.cmdBar->pushCurrentLine();
	if(!currentInput.isEmpty()){
		string inputStdString = currentInput.toLocal8Bit().constData();
		Messenger msg = scheduler->processCommand(inputStdString);
		handleMessenger(msg);
	}
}

void MainWindow::logStart(){
	const char* MAINWINDOW_NAME = "MainWindow";
	const char* START_INFO = "UI starts";
	::Logger* logger = ::Logger::getLogger();
	logger->log(MAINWINDOW_NAME, START_INFO, INFOLOG);
}

void MainWindow::logEnd(){
	const char* MAINWINDOW_NAME = "MainWindow";
	const char* END_INFO = "UI ends";
	::Logger* logger = ::Logger::getLogger();
	logger->log(MAINWINDOW_NAME, END_INFO, INFOLOG);
}

	// End of segment: C:\Users\a0102016\Desktop\asd\MainWindow.cpp





	/**
	 * origin: C:\Users\a0102016\Desktop\asd\QuickAddWindow.cpp
	 */

QuickAddWindow::QuickAddWindow(QWidget *parent):QDialog(parent){
	setupUi();
	customisedUi();
}

bool QuickAddWindow::eventFilter(QObject* watched, QEvent* event){
	bool FILTERED = true;

	if(watched == ui.cmdBar &&
		event->type() == QEvent::KeyPress){
		FILTERED = handleKeyEvent(FILTERED, watched, event);
	}
	else{
		//normal processing
		FILTERED = QObject::eventFilter(watched, event);
	}
	return FILTERED;
}

void QuickAddWindow::customisedUi(){
	setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::Dialog | Qt::Popup);
	setAttribute(Qt::WA_TranslucentBackground);
	setWindowState(Qt::WindowActive);
}

void QuickAddWindow::mousePressEvent(QMouseEvent *event){
	this->windowPosition = this->pos();
	this->mousePressPosition = event->globalPos();
}

void QuickAddWindow::mouseMoveEvent(QMouseEvent *event){
	this->mouseMovePosition = event->globalPos();
	QPoint distanceToMove = this->mouseMovePosition - this->mousePressPosition + this->windowPosition;
	this->move(distanceToMove);   
}

void QuickAddWindow::emitRequest(QString requestStr){
	//notify the parent, there is a request submitted by user
	emit requestSubmitted(requestStr);
}

void QuickAddWindow::emitWindowClosed(){
	//notify the parent, to close the quick add window
	emit windowClosed();
}

void QuickAddWindow::setupUi()
{
	ui.setupUi(this);
	ui.cmdBar->installEventFilter(this);
	ui.cmdBar->setQuickAddMode();
}

bool QuickAddWindow::handleKeyEvent( bool &FILTERED, QObject* watched, QEvent* event ){
	QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
	if(keyEvent->key() == Qt::Key_Escape){
		handleKeyEscape();
	}
	else if(keyEvent->key() == Qt::Key_Return || keyEvent->key() == Qt::Key_Enter){
		handleKeyEnter();
	}
	else{
		//normal processing
		FILTERED = QObject::eventFilter(watched, event);
	}
	return FILTERED;
}

void QuickAddWindow::handleKeyEscape(){
	emitWindowClosed();
	//wait for parent window to close it
}

void QuickAddWindow::handleKeyEnter(){
	QString currentInput = ui.cmdBar->getCurrentLine();
	ui.cmdBar->pushCurrentLine();
	if(!currentInput.isEmpty()){
		emitRequest(currentInput);
		//wait for parent window to decide whether close it or not
	}
}

	// End of segment: C:\Users\a0102016\Desktop\asd\QuickAddWindow.cpp





